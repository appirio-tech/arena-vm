/*
 * Deployer
 * 
 * Created 08/31/2006
 */
package com.topcoder.farm.deployer;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import com.topcoder.farm.deployer.process.ProcessRunner;
import com.topcoder.farm.deployer.process.ProcessRunnerException;
import com.topcoder.farm.deployer.process.ProcessTimeoutException;
import com.topcoder.farm.deployer.web.DeploymentHelper;
import com.topcoder.farm.shared.util.zip.ZipUtil;

/**
 * The deployer is responsible for doing all required tasks to check/unpack
 * files generated by the Farm-Deployer application. <p> 
 * Commonly, you should use this class in the processor or in the controller 
 * to update node. 
 * 
 *   
 * @author Diego Belfer (mural)
 * @version $Id$
 */
public class Deployer {
    /**
     * Time to wait for post install script finalization
     * FIXME remove hardcoded value
     */
    private static final int TIME_FOR_POST_INSTALL_SCRIPT = 30000;
    private static final String ENCODING = DeploymentHelper.ENCODING;

    
    /**
     * Deploy the node if it is necessary.
     * 
     * @param id The id of the node
     * @param rootFolder The rootFolder where deployment should be done.
     * 
     * @throws DeploymentException If the deployment process cannot be done
     */
    public void deploy(String id, String rootFolder) throws DeploymentException {
        String runningVersion = null;
        try {
            String deployZipFile = DeploymentHelper.DEPLOY_ZIP_FILE;
            runningVersion = getRunningVersion();
            boolean mustDeploy = true;
            File root = new File(rootFolder);
            File deployedVersionFile = new File(root, "deployed");
            if (runningVersion != null && root.exists()) {
                try {
                    String deployed = FileUtils.readFileToString(deployedVersionFile, ENCODING);
                    mustDeploy = !deployed.trim().equals(runningVersion); 
                } catch (Exception e) {
                }
            }
            if (runningVersion != null && mustDeploy) {
                File idFile = new File(root, "idfile");
                cleanIfExists(root);
                ZipUtil.unzip(Deployer.class.getResourceAsStream("/"+deployZipFile), root);
                FileUtils.writeStringToFile(deployedVersionFile, runningVersion, ENCODING);
                runInstallationScript(root);
                FileUtils.writeStringToFile(idFile, id, ENCODING);
                ;
            }
        } catch (Exception e) {
            throw new DeploymentException("Could not install version "+ runningVersion, e);
        } 
    }

    /**
     * Tries to delete folder contents if it exists
     * 
     * @param folder The folder to delete
     * @throws IOException If the folder could not be deleted
     */
    private void cleanIfExists(File folder) throws IOException {
        if (folder.exists()) {
            FileUtils.cleanDirectory(folder);
        }
    }
   
    /**
     * Runs the installation script if it exist
     * 
     * @param root Root folder
     */
    private void runInstallationScript(File root) throws ProcessTimeoutException, ProcessRunnerException {
        String[] cmd = null;
        if (File.separatorChar == '/') {
            File script = new File(root, "install.sh");
            if (script.exists()) {
                cmd = new String[] {"sh", script.getAbsolutePath()};
            }
        } else {
            File script = new File(root, "install.bat");
            if (script.exists()) {
                cmd = new String[] {script.getAbsolutePath()};
            }
        }
        if (cmd != null) {
            ProcessRunner runner = new ProcessRunner(cmd, root, TIME_FOR_POST_INSTALL_SCRIPT);
            runner.run();
        }
    }

    private String getRunningVersion() throws IOException {
        InputStream is = Deployer.class.getResourceAsStream("/"+DeploymentHelper.VERSION_FILE);
        if (is == null) {
            return null;
        }
        return IOUtils.toString(is, ENCODING);
    }
}
