#!/usr/local/bin/perl -- -*- C -*-
#------------ Excerpt from cgi-lib package ---------------------
# Perl Routines to Manipulate CGI input
# S.E.Brenner@bioc.cam.ac.uk
#
# Copyright (c) 1995 Steven E. Brenner  
# Unpublished work.
sub ReadParse {
  local (*in) = @_ if @_;
  local ($i, $key, $val);
  # Read in text
  if (&MethGet) {
	  $in = $ENV{'QUERY_STRING'};
  } elsif (&MethPost) {
	  read(STDIN,$in,$ENV{'CONTENT_LENGTH'});
  }
  @in = split(/[&;]/,$in); 
  foreach $i (0 .. $#in) {
	  # Convert plus's to spaces
	  $in[$i] =~ s/\+/ /g;
	  # Split into key and value.  
	  ($key, $val) = split(/=/,$in[$i],2);
	  # Convert %XX from hex numbers to alphanumeric
	  $key =~ s/%(..)/pack("c",hex($1))/ge;
	  $val =~ s/%(..)/pack("c",hex($1))/ge;
	  # Associate key and value
	  $in{$key} .= "\0" if (defined($in{$key}));
	  $in{$key} .= $val;
  }
  return scalar(@in); 
}
sub MethGet {
  return ($ENV{'REQUEST_METHOD'} eq "GET");
}
sub MethPost {
  return ($ENV{'REQUEST_METHOD'} eq "POST");
}
#----------- End of Excerpt from cgi-lib package ---------------
&ReadParse( *options );
print "Content-type: text/html\n\n";
print "<html><head><title>Keyword Search Results</title>\n";
print "</head>\n<body text=#000000 bgcolor=#FFFFFF>\n";
print "<h1>Keyword Search Results</h1>\n<hr><br><p>\n";
$datafile = $0;
$datafile =~ /(.+[\\\/])/;
$datafile = "${1}keyword.xrf";
if ( $options{'keys'} eq "" )
{
	  print "<big>No keywords specified.</big><p>\n";
}
elsif ( open( KEYS, $datafile ) )
{
	  push( @keyarray, split( / +/, $options{'keys'} ) );
	  if ( $options{'boolmode'} eq "or" )
	  {
	    while ( <KEYS> )
	    {
		($keyword, $classname, $path) = split( / +/, $_ );
		foreach $searchkey ( @keyarray )
		{
		    if ( $keyword   =~ /$searchkey/i  ||
			 $classname =~ /$searchkey/i )
		    {
			$inlist = "false";
			foreach $match ( @matches )
			{
			    if ( $match  eq  "$classname^$path" )
			    {
				$inlist = "true";
			    }
			}
			if ( $inlist  eq  "false" )
			{
			    push( @matches, "$classname^$path" );
			}
		    }
		}
	    }
	  }
	  else
	  {
	    $firsttime = "true";
	    foreach $searchkey ( @keyarray )
	    {
		while ( <KEYS> )
		{
		    ($keyword, $classname, $path) = split( / +/, $_ );
		    if ( $keyword   =~ /$searchkey/i  ||
			 $classname =~ /$searchkey/i )
		    {
			if ( $firsttime  eq  "true" )
			{
			    $inlist = "false";
			    foreach $match ( @matches )
			    {
				if ( $match eq "$classname^$path" )
				{
				    $inlist = "true";
				}
			    }
			    if ( $inlist  eq  "false" )
			    {
				push( @matches, "$classname^$path" );
			    }
			}
		    }
		    elsif ( $firsttime ne "true" )	# remove if already matched
		    {
			$i = 0;
			foreach $match ( @matches )
			{
			    if ( $match  eq  "$classname^$path" )
			    {
				splice( @matches, $i, 1 );
				last;
			    }
			    $i = $i + 1;
			}
		    }
		}
		if ( $#matches == -1 )
		{
		    last;
		}
		seek( KEYS, 0, 0 );
		$firsttime = "false";
	    }
	  }
	  close( KEYS );
	  if ( $#matches < 0 )
	  {
	    print "<big>No classes matched.</big><p>\n";
	  }
	  else
	  {
	    $number = $#matches + 1;
	    print "<big><b>Matched $number item(s):</b></big>\n<p>";
	    print "<ul><ul>\n";
	    foreach $matchclass ( @matches )
	    {
		($classname, $path) = split( /\^/, $matchclass );
		$path =~ s/\n//;
		print "<li><a href=\"$path$classname.htm\">$classname</a>\n";
	    }
	    print "</ul></ul>\n";
	  }
}
else
{
	  print "<big>No keyword file found!</big><p>\n";
}
print "<hr>Generated by Cocoon.<p></body></html>\n";
1;    # return true
