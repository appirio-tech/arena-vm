/*
 * User: Mike Cervantes (emcee)
 * Date: May 16, 2002
 * Time: 9:24:09 PM
 */
package com.topcoder.client.contestMonitor.model;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;

import com.topcoder.client.contestMonitor.view.gui.TimeOutException;
import com.topcoder.server.AdminListener.request.SecurityManagementRequest;
import com.topcoder.server.AdminListener.response.AddAnswerAck;
import com.topcoder.server.AdminListener.response.AddContestAck;
import com.topcoder.server.AdminListener.response.AddImportantMessageAck;
import com.topcoder.server.AdminListener.response.AddQuestionAck;
import com.topcoder.server.AdminListener.response.AddRoundAck;
import com.topcoder.server.AdminListener.response.BackupTablesAck;
import com.topcoder.server.AdminListener.response.ContestManagementAck;
import com.topcoder.server.AdminListener.response.ContestManagementSetupMessage;
import com.topcoder.server.AdminListener.response.DeleteAnswerAck;
import com.topcoder.server.AdminListener.response.DeleteContestAck;
import com.topcoder.server.AdminListener.response.DeleteQuestionAck;
import com.topcoder.server.AdminListener.response.DeleteRoundAck;
import com.topcoder.server.AdminListener.response.GetAllContestsAck;
import com.topcoder.server.AdminListener.response.GetAllImportantMessagesAck;
import com.topcoder.server.AdminListener.response.GetAnswersAck;
import com.topcoder.server.AdminListener.response.GetBackupCopiesResponse;
import com.topcoder.server.AdminListener.response.GetNewIDResponse;
import com.topcoder.server.AdminListener.response.GetPrincipalsResponse;
import com.topcoder.server.AdminListener.response.GetProblemsAck;
import com.topcoder.server.AdminListener.response.GetQuestionsAck;
import com.topcoder.server.AdminListener.response.GetRoundProblemComponentsAck;
import com.topcoder.server.AdminListener.response.GetRoundsAck;
import com.topcoder.server.AdminListener.response.ModifyAnswerAck;
import com.topcoder.server.AdminListener.response.ModifyContestAck;
import com.topcoder.server.AdminListener.response.ModifyMessageAck;
import com.topcoder.server.AdminListener.response.ModifyQuestionAck;
import com.topcoder.server.AdminListener.response.ModifyRoundAck;
import com.topcoder.server.AdminListener.response.RestartServiceAck;
import com.topcoder.server.AdminListener.response.RestoreTablesAck;
import com.topcoder.server.AdminListener.response.SaveRoundRoomAssignmentAck;
import com.topcoder.server.AdminListener.response.SecurityManagementAck;
import com.topcoder.server.AdminListener.response.SetComponentsAck;
import com.topcoder.server.AdminListener.response.SetRoundEventsAck;
import com.topcoder.server.AdminListener.response.SetRoundLanguagesAck;
import com.topcoder.server.AdminListener.response.SetRoundSegmentsAck;
import com.topcoder.server.AdminListener.response.SetSurveyAck;
import com.topcoder.server.AdminListener.response.VerifyRoundAck;
import com.topcoder.server.AdminListener.response.WarehouseLoadAck;
import com.topcoder.server.contest.AnswerData;
import com.topcoder.server.contest.ComponentData;
import com.topcoder.server.contest.ContestData;
import com.topcoder.server.contest.Division;
import com.topcoder.server.contest.ImportantMessageData;
import com.topcoder.server.contest.ProblemData;
import com.topcoder.server.contest.QuestionData;
import com.topcoder.server.contest.RoundComponentData;
import com.topcoder.server.contest.RoundData;
import com.topcoder.server.contest.RoundEventData;
import com.topcoder.server.contest.RoundLanguageData;
import com.topcoder.server.contest.RoundProblemData;
import com.topcoder.server.contest.RoundRoomAssignment;
import com.topcoder.server.contest.RoundSegmentData;
import com.topcoder.server.contest.SurveyData;
import com.topcoder.shared.util.logging.Logger;


/**
 * Modifications for AdminTool 2.0 are :
 * <p>New <code>getNewID(int, ResponseWaiter)</code> method added to
 * meet the "1.2.1 Using Sequences when creating rounds" requirement.
 * <p>New private instance variable of type <code>GetNewIDResponse</code>
 * added to hold the response to request for new ID generated by requested
 * sequence.
 * <p>New public method to get the response to request for new round ID added.
 * See Documentation for <code>getNewIDResponse</code> method.
 * <p>New public method <code>saveRoundRoomAssignment(RoundRoomAssignment,
 * ResponseWaiter)</code> added to send a request to save new room assignment
 * details for specified round at server side.
 * <p>Existing method <code>recieve(ContestManagementAck)</code> is modified
 * to support new types of responses declared by Admin Tool 2.0 application.
 * 
 * <p>
 * Changes in version 1.0 (TopCoder Competition Engine - Event Support For Registration v1.0):
 * <ol>
 * <li>Added {@link #setRoundEvents(RoundEventData eventData, ResponseWaiter waiter)} method.</li>
 * </ol>
 * </p>
 * @author TCDEVELOPER
 */
public class ContestManagementController {

    private static final Logger log = Logger.getLogger(ContestManagementController.class);

    private CommandSender sender;

    private Timer responseWaiterTimer = new Timer();
    private long TIMEOUT_MS = 20 * 1000;

    // TODO: At the moment LONG_TIMEOUT_MS is set to an extemely high value
    // TODO: so that in practice a timeout never occurs. During integration
    // TODO: we will have to run some benchmarks on the requests that use this
    // TODO: particular timeout and set its value to something higher than that
    // TODO: but not too far off.
    /**
     * A long timeout for operations that take time to execute
     * e.g. WarehouseLoadRequest
     */
    private long LONG_TIMEOUT_MS = 20000 * 1000;
    private Map waiters = Collections.synchronizedMap(new HashMap());

    private ContestSelectionTableModel contestSelectionTableModel = new ContestSelectionTableModel();
    private RoundSelectionTableModel roundSelectionTableModel = new RoundSelectionTableModel();
    private AnswerSelectionTableModel answerSelectionTableModel = new AnswerSelectionTableModel();
    private AssignedProblemsTableModel assignedProblemsTableModel = new AssignedProblemsTableModel();
    private AvailableProblemsTableModel availableProblemsTableModel = new AvailableProblemsTableModel();
    private QuestionSelectionTableModel questionSelectionTableModel = new QuestionSelectionTableModel();
    private ProblemComponentsTableModel problemComponentsTableModel = new ProblemComponentsTableModel();
    private ImportantMessageSelectionTableModel messageSelectionTableModel = new ImportantMessageSelectionTableModel();

    private Collection roundTypes = new Vector(),
    seasons = new Vector(),
    regions = new Vector(),
    problemStatusTypes = new Vector(),
    difficultyLevels = new Vector(),
    divisions = new Vector(),
    surveyStatusTypes = new Vector(),
    questionTypes = new Vector(),
    questionStyles = new Vector(),
    languages = new Vector();

    private HashMap componentDataDiv1 = new HashMap();
    private HashMap componentDataDiv2 = new HashMap();

    /**
     * A response to request for list of existing backup copies for specified
     * round.
     * This variable is set by <code>ContestManagementController</code> when
     * <code>GetBackupCopiesResponse</code> representing the response to
     * request for list of existing backup copies for specified round is
     * received by <code>receive</code> method and retrieved by class that
     * initiated the request. After the value of this variable is retrieved
     * by requestor this variable is nullified.<p/>
     * <b>NOTE:</b> access to this variable should be synchronized.<p/>
     * <b>NOTE:</b> it is a responsibility of requestor to retrieve the value of
     * this variable as faster as possible after notification on response
     * arrival.
     *
     * @since Admin Tool 2.0
     */
    private GetBackupCopiesResponse backupCopiesResponse = null;

    /**
     * A response to request for list of existing principals of specified 
     * type.
     * This variable is set by <code>ContestManagementController</code> when 
     * <code>GetPrincipalResponse</code> representing the response to 
     * request for list of existing principals of specified type is 
     * received by <code>receive</code> method and retrieved by class that 
     * initiated the request. After the value of this variable is retrieved 
     * by requestor this variable is nullified.<p>
     * NOTE : access to this variable should be synchronized.<p>
     * NOTE : it is a responsibility of requestor to retrieve the value of 
     * this variable as faster as possible after notification on response
     * arrival.
     *
     * @since Admin Tool 2.0
     */
    private GetPrincipalsResponse principalsResponse = null;

    /**
     * A response to request for new ID generated by requested sequence. 
     * This variable is setted by
     * <code>ContestManagementController</code> when 
     * <code>GetNewIDResponse</code> representing the response to request
     * for new ID is received by <code>receive</code> method and 
     * retrieved by class that initiated the request. After the value of
     * this variable is retrieved by requestor this variable is nullified. <p>
     * NOTE : access to this variable should be synchronized.<p>
     * NOTE : it is a responsibility of requestor to retrieve the value of 
     * this variable as faster as possible after notification on response
     * arrival.
     *
     * @since Admin Tool 2.0
     */
    private GetNewIDResponse newIDResponse = null;
    
    public static interface SetupListener {
        void setup();
    }

    private Set setupListeners = new HashSet();

    public synchronized void registerSetupListener(SetupListener listener) {
        setupListeners.add(new WeakReference(listener));
    }

    private synchronized void notifySetupListeners() {
        for (Iterator it = setupListeners.iterator(); it.hasNext();) {
            SetupListener listener = (SetupListener) ((WeakReference) it.next()).get();
            if (listener != null) {
                listener.setup();
            } else {
                it.remove();
            }
        }
    }

    private class InternalWaiter {

        private ResponseWaiter viewWaiter;
        private TimerTask timeOutTask;

        InternalWaiter(final ResponseWaiter viewWaiter) {
            this.viewWaiter = viewWaiter;
        }

        public void waitForResponse(TimerTask timeOutTask) {
            this.timeOutTask = timeOutTask;
            viewWaiter.waitForResponse();
        }

        public void errorResponseReceived(Throwable t) {
            timeOutTask.cancel();
            viewWaiter.errorResponseReceived(t);
        }

        public void responseReceived() {
            timeOutTask.cancel();
            viewWaiter.responseReceived();
        }
    };


    public ContestManagementController(CommandSender sender, int timeout) {
        this.sender = sender;
        this.TIMEOUT_MS = timeout * 1000;
    }


    /**
     * This method was modified to support processing of new types of
     * responses declared by Admin Tool 2.0 application. Those types of requests
     * are : <code>BackupTablesAck</code>, <code>GetBackupCopiesResponse</code>
     * , <code>GetNewIDResponse</code>, <code>GetRegisteredCodersResponse</code>
     * , <code>WarehouseLoadAck</code>, , <code>SetRoundTermsAck</code>
     * , <code>RestartServiceAck</code>, <code>SaveRoundRoomAssignmentAck</code>,
     * <code>RestoreTablesAck</code>, <code>GetPrincipalsResponse</code>,
     * <code>SecurityManagementAck</code>
     *
     * @see BackupTablesAck
     * @see GetBackupCopiesResponse
     * @see GetNewIDResponse
     * @see GetPrincipalsResponse
     * @see com.topcoder.server.AdminListener.response.RestartServiceAck
     * @see RestoreTablesAck
     * @see com.topcoder.server.AdminListener.response.SaveRoundRoomAssignmentAck
     * @see com.topcoder.server.AdminListener.response.SetRoundTermsAck
     * @see WarehouseLoadAck
     * @see com.topcoder.server.AdminListener.response.SecurityManagementAck
     */
    public void receive(ContestManagementAck ack) {
        InternalWaiter waiter = null;
        Class clazz = ack.getClass();
        
        if (waiters.containsKey(clazz)) {
            if (log.isDebugEnabled()) {
                log.debug("Removing waiter for " + clazz.getName());
            }
            waiter = (InternalWaiter) waiters.remove(clazz);
        }

        if (ack.hasException()) {
            log.error("Contest management ack contained error", ack.getException());
            if (waiter != null)
                waiter.errorResponseReceived(ack.getException());
            return;
        }

        if (ack instanceof ContestManagementSetupMessage) {
            log.debug("Recieved contest management setup...");
            ContestManagementSetupMessage msg = (ContestManagementSetupMessage) ack;
            roundTypes = msg.getRoundTypes();
            seasons = msg.getSeasons();
            regions = msg.getRegions();
            problemStatusTypes = msg.getProblemStatusTypes();
            difficultyLevels = msg.getDifficultyLevels();
            divisions = msg.getDivisions();
            surveyStatusTypes = msg.getSurveyStatusTypes();
            questionTypes = msg.getQuestionTypes();
            questionStyles = msg.getQuestionStyles();
            languages = msg.getLanguages();
            notifySetupListeners();
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetAllContestsAck) {
            log.debug("Received get contests ack...");
            contestSelectionTableModel.update(((GetAllContestsAck) ack).getContests());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetAllImportantMessagesAck) {
            log.debug("Received get messages ack...");
            messageSelectionTableModel.update(((GetAllImportantMessagesAck) ack).getMessages());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof AddContestAck) {
            log.debug("Received add contest ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof ModifyContestAck) {
            log.debug("Received modify contest ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof AddImportantMessageAck) { 
            log.debug("Received add message ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof ModifyMessageAck) {
            log.debug("Received modify message ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof DeleteContestAck) {
            log.debug("Received delete contest ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetRoundsAck) {
            log.debug("Received get rounds ack...");
            roundSelectionTableModel.update(((GetRoundsAck) ack).getRounds());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof AddRoundAck) {
            log.debug("Received add round ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof ModifyRoundAck) {
            log.debug("Received modify round ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof DeleteRoundAck) {
            log.debug("Received delete round ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof VerifyRoundAck) {
            log.debug("Received verify round ack...");
            if (waiter != null) {
                if (waiter instanceof VerifyRoundInternalWaiter) {
                    ((VerifyRoundInternalWaiter) waiter).setVerificationText(((VerifyRoundAck) ack).getText());
                }
                waiter.responseReceived();
            }
        } else if (ack instanceof SetRoundEventsAck) {
            log.debug("Received set round events ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SetRoundSegmentsAck) {
            log.debug("Received set round segments ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SetRoundLanguagesAck) {
                log.debug("Received set round languages ack...");
                if (waiter != null)
                    waiter.responseReceived();
        } else if (ack instanceof GetProblemsAck) {
            log.debug("Received get problems ack...");
            assignedProblemsTableModel.update(((GetProblemsAck) ack).getAssignedProblems());
            availableProblemsTableModel.update(((GetProblemsAck) ack).getProblems());
            componentDataDiv1.clear();
            componentDataDiv2.clear();
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetRoundProblemComponentsAck) {
            log.debug("Received get components ack...");
            problemComponentsTableModel.update(((GetRoundProblemComponentsAck) ack).getComponents());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SetComponentsAck) {
            log.debug("Received set problems ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SetSurveyAck) {
            log.debug("Received set survey ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetQuestionsAck) {
            log.debug("Received get questions ack...");
            questionSelectionTableModel.update(((GetQuestionsAck) ack).getQuestions());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof AddQuestionAck) {
            log.debug("Received add question ack...");
            if (waiter != null) {
                if (waiter instanceof AddQuestionInternalWaiter) {
                    ((AddQuestionInternalWaiter) waiter).setQuestionID(
                            ((AddQuestionAck) ack).getQuestionID()
                    );
                }
                waiter.responseReceived();
            }
        } else if (ack instanceof ModifyQuestionAck) {
            log.debug("Received modify question ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof DeleteQuestionAck) {
            log.debug("Received delete question ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetAnswersAck) {
            log.debug("Received get answers ack...");
            answerSelectionTableModel.update(((GetAnswersAck) ack).getAnswers());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof AddAnswerAck) {
            log.debug("Received add answer ack...");
            if (waiter != null) {
                if (waiter instanceof AddAnswerInternalWaiter) {
                    ((AddAnswerInternalWaiter) waiter).setAnswerID(
                            ((AddAnswerAck) ack).getAnswerID()
                    );
                }
                waiter.responseReceived();
            }
        } else if (ack instanceof ModifyAnswerAck) {
            log.debug("Received modify answer ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof DeleteAnswerAck) {
            log.debug("Received delete answer ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof RestartServiceAck) {
            log.debug("Received restart service ack...");
            if (waiter != null) {
                if (ack.isSuccess()) {
                    waiter.responseReceived();
                } else {
                    waiter.errorResponseReceived(ack.getException());
                }
            }
        } else if (ack instanceof BackupTablesAck) {
            log.debug("Received backup tables ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetBackupCopiesResponse) {
            log.debug("Received get backup copies response...");
            if (waiter != null) {
                backupCopiesResponse = (GetBackupCopiesResponse) ack;
                waiter.responseReceived();
            }
        } else if (ack instanceof RestoreTablesAck) {
            log.debug("Received restore tables ack...");
            if (waiter != null)
                waiter.responseReceived();
         } else if (ack instanceof WarehouseLoadAck) {
            log.debug("Received warehouse load ack...");
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetNewIDResponse) {
            log.debug("Received get new id response...ID = " + ((GetNewIDResponse) ack).getNewId());
            newIDResponse = (GetNewIDResponse)ack;
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SaveRoundRoomAssignmentAck) {
            log.debug("Received save roundroomassignment ack id = " + ((SaveRoundRoomAssignmentAck) ack).getRoundID());
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof GetPrincipalsResponse) {
            log.debug("Received get principals response type...= " + ((GetPrincipalsResponse) ack).getType() );
            principalsResponse = (GetPrincipalsResponse)ack;
            if (waiter != null)
                waiter.responseReceived();
        } else if (ack instanceof SecurityManagementAck) {
            log.debug("Received security management ack " );
            if (waiter != null)
                waiter.responseReceived();
        } else {
            Exception e = new IllegalArgumentException("Unrecognized response: " + ack);
            log.error(e);
            if (waiter != null)
                waiter.errorResponseReceived(e);
        }
    }

    public ImportantMessageSelectionTableModel getImportantMessageSelectionTableModel() {
        return messageSelectionTableModel;
    }

    public ContestSelectionTableModel getContestSelectionTableModel() {
        return contestSelectionTableModel;
    }

    public RoundSelectionTableModel getRoundSelectionTableModel() {
        return roundSelectionTableModel;
    }

    public AnswerSelectionTableModel getAnswerSelectionTableModel() {
        return answerSelectionTableModel;
    }

    public AssignedProblemsTableModel getAssignedProblemsTableModel() {
        return assignedProblemsTableModel;
    }

    public AvailableProblemsTableModel getAvailableProblemsTableModel() {
        return availableProblemsTableModel;
    }

    public ProblemComponentsTableModel getProblemComponentsTableModel() {
        return problemComponentsTableModel;
    }

    public QuestionSelectionTableModel getQuestionSelectionTableModel() {
        return questionSelectionTableModel;
    }


    private void addWaiter(final Class responseClazz, final InternalWaiter waiter) {
        if (waiter != null) {
            if (!waiters.containsKey(responseClazz)) {
                TimerTask task = new TimerTask() {
                    public void run() {
                        waiters.remove(responseClazz);
                        Exception e = new TimeOutException();
                        e.fillInStackTrace();
                        log.error(e);
                        waiter.errorResponseReceived(e);
                    }
                };
                waiter.waitForResponse(task);
                responseWaiterTimer.schedule(task, TIMEOUT_MS);
                waiters.put(responseClazz, waiter);
            } else {
                throw new IllegalStateException("Only one waiter for a given response type at a time!  Tried to add second waiter for " + responseClazz.getName());
            }
        }
    }

    /**
     * Adds a waiter to the list of waiters for a specified response class.
     * It also accepts as an argument the milliseconds after which the waiter
     * will timeout and stop expecting a response.
     *
     * @param responseClazz the type of response the waiter is expecting
     * @param waiter a waiter that will notified on arrival of specified response
     * @param delay how many milliseconds before the waiter times out
     *
     * @since  Admin Tool 2.0
     *
     * @see ContestManagementController#addWaiter(java.lang.Class, InternalWaiter)
     */
    private void addWaiter(final Class responseClazz, final InternalWaiter waiter, long delay) {
        if (waiter != null) {
            if (!waiters.containsKey(responseClazz)) {
                TimerTask task = new TimerTask() {
                    public void run() {
                        waiters.remove(responseClazz);
                        Exception e = new TimeOutException();
                        e.fillInStackTrace();
                        log.error(e);
                        waiter.errorResponseReceived(e);
                    }
                };
                waiter.waitForResponse(task);
                responseWaiterTimer.schedule(task, delay);
                waiters.put(responseClazz, waiter);
            } else {
                throw new IllegalStateException("Only one waiter for a given response type at a time!  Tried to add second waiter for " + responseClazz.getName());
            }
        }
    }


    /**
     * Sends the request for new ID to Admin Listener server. To do so
     * registers specified waiter to receive notifications on <code>
     * GetNewIDResponse</code> arrival and invokes <code>
     * CommandSender.sendGetNewID(int)</code> method.
     *
     * @param sequence an ID of sequence that should be used to generate new
     *        ID
     * @param waiter a ResponseWaiter to be notified when the response to
     *        request for new ID becomes available.
     * @since Admin Tool 2.0
     * @see   GetNewIDResponse
     * @see   #addWaiter
     * @see   CommandSender#sendGetNewID
     */
    public void getNewID(String sequence, ResponseWaiter waiter) {
        addWaiter(GetNewIDResponse.class, new InternalWaiter(waiter));
        sender.sendGetNewID(sequence);
    }

    /**
     * Gets the response to request for new ID. It is a responsibility
     * of invoker of this method to call it in appropriate time, namely this
     * method should be invoked after notification on response arrival.<p>
     * After invocation of this method the value of <code>newIDResponse
     * </code> variable should be nullified.
     *
     * @return a GetNewIDResponse containing the new ID generated by specified
     *         sequence
     * @since  Admin Tool 2.0
     * @see    GetNewIDResponse
     * @see    #newIDResponse
     */
    public synchronized GetNewIDResponse getNewIDResponse() {
        GetNewIDResponse ret = newIDResponse;
        newIDResponse = null;
        return ret;
    }


    public void getAllContests(ResponseWaiter waiter) {
        addWaiter(GetAllContestsAck.class, new InternalWaiter(waiter));
        sender.sendGetAllContests();
    }
    
    public void getAllImportantMessages(ResponseWaiter waiter) {
        addWaiter(GetAllImportantMessagesAck.class, new InternalWaiter(waiter));
        sender.sendGetAllImportantMessages();
    }


    public void deleteContest(final ContestData contest, ResponseWaiter waiter) {
        addWaiter(
                DeleteContestAck.class,
                new InternalWaiter(waiter) {
                    public void responseReceived() {
                        super.responseReceived();
                        contestSelectionTableModel.remove(contest);
                    }
                }
        );
        sender.sendDeleteContest(contest.getId());
    }


    public void addContest(final ContestData contest, ResponseWaiter waiter) {
        addWaiter(AddContestAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                contestSelectionTableModel.add(contest);
            }
        });
        sender.sendAddContest(contest);
    }


    public void modifyContest(final ContestData oldContest, final ContestData newContest, ResponseWaiter waiter) {
        addWaiter(
                ModifyContestAck.class,
                new InternalWaiter(waiter) {
                    public void responseReceived() {
                        super.responseReceived();
                        contestSelectionTableModel.remove(oldContest);
                        contestSelectionTableModel.add(newContest);
                    }
                }
        );
        sender.sendModifyContest(oldContest.getId(), newContest);
    }
    
    public void addMessage(final ImportantMessageData message, ResponseWaiter waiter) {
        addWaiter(AddImportantMessageAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                messageSelectionTableModel.add(message);
            }
        });
        sender.sendAddMessage(message);
    }


    public void modifyMessage(final ImportantMessageData oldMessage, final ImportantMessageData newMessage, ResponseWaiter waiter) {
        addWaiter(
                ModifyMessageAck.class,
                new InternalWaiter(waiter) {
                    public void responseReceived() {
                        super.responseReceived();
                        messageSelectionTableModel.remove(oldMessage);
                        messageSelectionTableModel.add(newMessage);
                    }
                }
        );
        sender.sendModifyMessage(oldMessage.getId(), newMessage);
    }

    public void getRounds(ContestData contest, ResponseWaiter waiter) {
        addWaiter(GetRoundsAck.class, new InternalWaiter(waiter));
        sender.sendGetRounds(contest.getId());
    }


    public void addRound(final RoundData round, ResponseWaiter waiter) {
        addWaiter(AddRoundAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                roundSelectionTableModel.add(round);
            }
        });
        sender.sendAddRound(round);
    }


    public void modifyRound(final RoundData oldRound, final RoundData newRound, ResponseWaiter waiter) {
        addWaiter(ModifyRoundAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                roundSelectionTableModel.remove(oldRound);
                roundSelectionTableModel.add(newRound);
            }
        });
        sender.sendModifyRound(oldRound.getId(), newRound);
    }


    public void deleteRound(final RoundData round, ResponseWaiter waiter) {
        addWaiter(DeleteRoundAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                roundSelectionTableModel.remove(round);
            }
        });
        sender.sendDeleteRound(round.getId());
    }

    /**
     * Sends the request to save given round room assignment details to 
     * Admin Listener server. To do so registers specified waiter to receive
     * notifications on <code>SaveRoundRoomAssignmentAck</code> arrival 
     * and invokes <code>
     * CommandSender.sendSaveRoundRoomAssignment(RoundRoomAssinmnet)</code>
     * method.
     *
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request for registered coders becomes available.
     * @throws IllegalArgumentException if given RoundRoomAssignment parameter
     *         is null
     * @since  Admin Tool 2.0
     * @see    CommandSender#sendSaveRoundRoomAssignment
     * @see    SaveRoundRoomAssignmentAck
     */
    public void saveRoundRoomAssignment(RoundRoomAssignment details,
        ResponseWaiter waiter) {
        if(details == null )
            throw new IllegalArgumentException("details cannot be null");
        
        addWaiter(SaveRoundRoomAssignmentAck.class, new InternalWaiter(waiter));
        sender.sendSaveRoundRoomAssignment(details);
    }

    /**
     * Sends the request for list of existing principals of specified type
     * to Admin Listener server. To do so registers specified waiter 
     * to receive notifications on <code>GetPrincipalsResponse</code> arrival 
     * and invokes <code>CommandSender.sendGetPrincipals(int)</code> method.
     *
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request becomes available.
     * @since  Admin Tool 2.0
     * @see    CommandSender#sendGetPrincipals
     * @see    GetPrincipalsResponse
     */
    public void getPrincipals(int type, ResponseWaiter waiter) {
        addWaiter(GetPrincipalsResponse.class, new InternalWaiter(waiter));
        sender.sendGetPrincipals(type);
    }

    /**
     * Gets the response to request for list of existing principals of specified
     * type. It is a responsibility of invoker of this method 
     * to call it in appropriate time, namely this method should be invoked 
     * after notification on response arrival.<p>
     * After invocation of this method the value of <code>
     * principalsResponse</code> variable should be nullified.
     *
     * @return a GetPrincipalsResponse containing the list of TCPrincipals
     *         of requested type
     * @since  Admin Tool 2.0
     * @see    GetPrincipalsResponse
     * @see    #principalsResponse
     */
    public GetPrincipalsResponse getPrincipalsResponse() {
        GetPrincipalsResponse ret = principalsResponse;
        principalsResponse = null;
        return ret;
    }

    /**
     * Sends a request to perform specified security schema management operation
     * to Admin Listener server.  To do so registers specified waiter 
     * to receive notifications on <code>SecurityManagementAck</code> arrival 
     * and invokes <code>CommandSender.sendSecurityRequest()</code> method.
     *
     * @param request a SecurityManagementRequest to be sent to Admin Listener 
     *        server
     * @param waiter a ResponseWaiter to be notified on response arrival
     * @throws IllegalArgumentException if any given request is null
     * @since  Admin Tool 2.0
     */
    public void sendSecurityRequest(SecurityManagementRequest request,
        ResponseWaiter waiter) {
        addWaiter(SecurityManagementAck.class, new InternalWaiter(waiter));
        sender.sendSecurityRequest(request);
    }
    
    private class VerifyRoundInternalWaiter extends InternalWaiter {

        private StringBuffer textBuffer;

        public void setVerificationText(String text) {
            textBuffer.append(text);
        }

        public VerifyRoundInternalWaiter(ResponseWaiter child, StringBuffer buffer) {
            super(child);
            this.textBuffer = buffer;
        }
    }

    public void verifyRound(final RoundData round, StringBuffer buffer, ResponseWaiter waiter) {
        addWaiter(VerifyRoundAck.class, new VerifyRoundInternalWaiter(waiter, buffer));
        sender.sendVerifyRound(round.getId());
    }


    public Collection getRoundTypes() {
        return roundTypes;
    }
    
    public Collection getSeasons() {
        return seasons;
    }
    
    public Collection getRegions() {
        return regions;
    }
    
    public Collection getLanguages() {
        return languages;
    }

    public void setRoundSegments(RoundSegmentData segments, ResponseWaiter waiter) {
        addWaiter(SetRoundSegmentsAck.class, new InternalWaiter(waiter));
        sender.sendSetSegments(segments);
    }
    /**
     * <p>
     * send the command of setting events.
     * </p>
     * @param eventData
     *         the round event data.
     * @param waiter
     *        the response waiter.
     */
    public void setRoundEvents(RoundEventData eventData, ResponseWaiter waiter) {
        addWaiter(SetRoundEventsAck.class, new InternalWaiter(waiter));
        sender.sendSetEvents(eventData);
    }

    public void setRoundLanguages(RoundLanguageData languages, ResponseWaiter waiter) {
        addWaiter(SetRoundLanguagesAck.class, new InternalWaiter(waiter));
        sender.sendSetLanguages(languages);
    }

    public void getProblems(RoundData round, ResponseWaiter waiter) {
        addWaiter(GetProblemsAck.class, new InternalWaiter(waiter));
        sender.sendGetProblems(round.getId());
    }

    /**
     * Requests the list of components of all problems assigned to the round identified
     * by roundID
     *
     * @param roundID the roundID of the round whose components will be fetched
     * @param waiter a waiter to be notified upon arrival of the response to the request
     */
    public void getComponents(int roundID, ResponseWaiter waiter) {
        addWaiter(GetRoundProblemComponentsAck.class, new InternalWaiter(waiter));
        sender.sendGetRoundProblemComponents(roundID);
    }


    /**
     * This method gets the components for a problem.  It has to be very careful since this
     * controller stores component data up until the RoundProblem frame is closed.  Therefore,
     * this method checks for any components with data already saved, and if there are any,
     * uses this information instead of an EJB call to fill the table.
     * @param round
     * @param rp
     * @param waiter
     */
    public void getComponents(RoundData round, RoundProblemData rp, ResponseWaiter waiter) {
        Collection components = new ArrayList();

        ProblemData problem = rp.getProblemData();

        HashMap componentData = null;
        if (rp.getDivision().getId() == 1)
            componentData = componentDataDiv1;
        else if (rp.getDivision().getId() == 2)
            componentData = componentDataDiv2;
        if (componentData != null) {
            synchronized (componentData) {
                for (Iterator it = componentData.values().iterator(); it.hasNext();) {
                    RoundComponentData rc = (RoundComponentData) it.next();
                    if (rc.getComponentData().getProblemId() == problem.getId()) {
                        components.add(rc);
                    }
                }
            }
        }
        if (!components.isEmpty()) {
            // we've found previously stored data; use it instead
            problemComponentsTableModel.update(components);
            waiter.waitForResponse();
            waiter.responseReceived();
        } else {
            addWaiter(GetRoundProblemComponentsAck.class, new InternalWaiter(waiter));
            sender.sendGetRoundProblemComponents(round.getId(), problem.getId(), rp.getDivision().getId());
        }
    }

    public void setProblems(RoundData round, ResponseWaiter waiter) {
        addWaiter(SetComponentsAck.class, new InternalWaiter(waiter));
        List items;

        synchronized (componentDataDiv1) {
            items = new ArrayList(componentDataDiv1.values());
        }
        synchronized (componentDataDiv2) {
            items.addAll(componentDataDiv2.values());
        }

        sender.sendSetComponents(round.getId(), items);
    }

    /**
     * Call this method to purge any information stored about a problem's components.
     * @param rp
     */
    public void removeProblem(RoundProblemData rp) {
        ProblemData problem = rp.getProblemData();

        HashMap componentData;
        if (rp.getDivision().getId() == 1)
            componentData = componentDataDiv1;
        else if (rp.getDivision().getId() == 2)
            componentData = componentDataDiv2;
        else
            return; // they can't have editted component data without setting division

        synchronized (componentData) {
            for (Iterator it = componentData.values().iterator(); it.hasNext();) {
                RoundComponentData rc = (RoundComponentData) it.next();
                if (rc.getComponentData().getProblemId() == problem.getId())
                    it.remove();
            }
        }
    }

    /**
     * Remove all data about components.
     */
    public void removeProblems() {
        synchronized (componentDataDiv1) {
            componentDataDiv1.clear();
        }
        synchronized (componentDataDiv2) {
            componentDataDiv2.clear();
        }
    }

    /**
     * This will store the components in the collection for a later call to setProblems()
     * @param components
     */

    public void setComponents(Collection components) {
        for (Iterator it = components.iterator(); it.hasNext();) {
            RoundComponentData rc = (RoundComponentData) it.next();
            if (rc.getDivision().getId() == 1) {
                synchronized (componentDataDiv1) {
                    componentDataDiv1.put(new Integer(rc.getComponentData().getId()), rc);
                }
            } else if (rc.getDivision().getId() == 2) {
                synchronized (componentDataDiv2) {
                    componentDataDiv2.put(new Integer(rc.getComponentData().getId()), rc);
                }
            } else
                throw new IllegalArgumentException("Component Division invalid");
        }
    }

    /**
     * Ensure that we have enough data from the user to commit components.  Specifically, we need data on every
     * component, for every problem, and there can't be any nulls.
     * @return whether or not setProblems can be called
     */
    public boolean canSetProblems() {
        Set problemsFound = new HashSet();
        synchronized (componentDataDiv1) {
            for (Iterator it = componentDataDiv1.values().iterator(); it.hasNext();) {
                RoundComponentData rc = (RoundComponentData) it.next();
                ComponentData cd = rc.getComponentData();
                problemsFound.add(new Integer(cd.getProblemId()));
                if (rc.getDifficulty().getDesc() == null || rc.getDivision().getDesc() == null) {
                    log.debug("Returning false in canSetProblems, div1 component: " + rc);
                    return false;
                }
            }
        }
        for (Iterator it = assignedProblemsTableModel.getRoundProblems().iterator(); it.hasNext();) {
            RoundProblemData rp = (RoundProblemData) it.next();
            if (rp.getDivision().getId() == 1 && !problemsFound.contains(new Integer(rp.getProblemData().getId()))) {
                log.debug("Returning false in canSetProblems, div1 problem not found.");
                return false;
            }
        }
        problemsFound.clear();
        synchronized (componentDataDiv2) {
            for (Iterator it = componentDataDiv2.values().iterator(); it.hasNext();) {
                RoundComponentData rc = (RoundComponentData) it.next();
                ComponentData cd = rc.getComponentData();
                problemsFound.add(new Integer(cd.getProblemId()));
                if (rc.getDifficulty().getDesc() == null || rc.getDivision().getDesc() == null) {
                    log.debug("Returning false in canSetProblems, div2 component: " + rc);
                    return false;
                }
            }
        }
        for (Iterator it = assignedProblemsTableModel.getRoundProblems().iterator(); it.hasNext();) {
            RoundProblemData rp = (RoundProblemData) it.next();
            if (rp.getDivision().getId() == 2 && !problemsFound.contains(new Integer(rp.getProblemData().getId()))) {
                log.warn("Returning false in canSetProblems, div2 problem not found.");
                return false;
            }
        }
        return true;
    }

    /**
     * Sets the division for the components currently being editted to the value passed in.
     * @param div
     */

    public void setDivision(Division div) {
        problemComponentsTableModel.setDivision(div);
    }

    public Collection getProblemStatusTypes() {
        return problemStatusTypes;
    }


    public Collection getDifficultyLevels() {
        return difficultyLevels;
    }


    public Collection getDivisions() {
        return divisions;
    }

    public Collection getSurveyStatusTypes() {
        return surveyStatusTypes;
    }


    public void setSurvey(SurveyData survey, ResponseWaiter waiter) {
        addWaiter(SetSurveyAck.class, new InternalWaiter(waiter));
        sender.sendSetSurvey(survey);
    }

    public Collection getQuestionTypes() {
        return questionTypes;
    }

    public Collection getQuestionStyles() {
        return questionStyles;
    }


    public void getQuestions(RoundData round, ResponseWaiter waiter) {
        addWaiter(GetQuestionsAck.class, new InternalWaiter(waiter));
        sender.sendGetQuestions(round.getId());
    }


    private class AddQuestionInternalWaiter extends InternalWaiter {

        private QuestionData question;

        public void setQuestionID(int questionID) {
            question.setId(questionID);
        }

        public AddQuestionInternalWaiter(ResponseWaiter child, QuestionData question) {
            super(child);
            this.question = question;
        }

        public void responseReceived() {
            super.responseReceived();
            questionSelectionTableModel.add(question);
        }
    }

    public void addQuestion(RoundData round, final QuestionData question, ResponseWaiter waiter) {
        addWaiter(AddQuestionAck.class, new AddQuestionInternalWaiter(waiter, question));
        sender.sendAddQuestion(round.getId(), question);
    }


    public void modifyQuestion(final QuestionData question, ResponseWaiter waiter) {
        addWaiter(ModifyQuestionAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                questionSelectionTableModel.remove(question);
                questionSelectionTableModel.add(question);
            }
        });
        sender.sendModifyQuestion(question);
    }


    public void deleteQuestion(final QuestionData question, ResponseWaiter waiter) {
        addWaiter(DeleteQuestionAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                questionSelectionTableModel.remove(question);
            }
        });
        sender.sendDeleteQuestion(question.getId());
    }


    public void getAnswers(QuestionData question, ResponseWaiter waiter) {
        addWaiter(GetAnswersAck.class, new InternalWaiter(waiter));
        sender.sendGetAnswers(question.getId());
    }


    private class AddAnswerInternalWaiter extends InternalWaiter {

        private AnswerData answer;

        public void setAnswerID(int answerID) {
            answer.setId(answerID);
        }

        public AddAnswerInternalWaiter(ResponseWaiter child, AnswerData answer) {
            super(child);
            this.answer = answer;
        }

        public void responseReceived() {
            super.responseReceived();
            answerSelectionTableModel.add(answer);
        }
    }

    public void addAnswer(QuestionData question, final AnswerData answer, ResponseWaiter waiter) {
        addWaiter(AddAnswerAck.class, new AddAnswerInternalWaiter(waiter, answer));
        sender.sendAddAnswer(question.getId(), answer);
    }


    public void modifyAnswer(QuestionData question, final AnswerData answer, ResponseWaiter waiter) {
        addWaiter(ModifyAnswerAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                answerSelectionTableModel.remove(answer);
                answerSelectionTableModel.add(answer);
            }
        });
        sender.sendModifyAnswer(answer);
    }


    public void deleteAnswer(final AnswerData answer, ResponseWaiter waiter) {
        addWaiter(DeleteAnswerAck.class, new InternalWaiter(waiter) {
            public void responseReceived() {
                super.responseReceived();
                answerSelectionTableModel.remove(answer);
            }
        });
        sender.sendDeleteAnswer(answer.getId());
    }

    /**
     * Sends the request for backup specified tables for specified round
     * to Admin Listener server. To do so registers specified waiter
     * to receive notifications on <code>BackupTablesAck</code> arrival
     * and invokes <code>CommandSender.sendBackupTables(int, Set)</code> method.
     *
     * @param  roundID an ID of round to create backup copy for
     * @param  tableNames a Set of String names of tables to back up
     * @param  comment a String comment of the backup
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request becomes available.
     *
     * @throws IllegalArgumentException if given Set is null
     *
     * @since  Admin Tool 2.0
     *
     * @see    CommandSender#sendBackupTables(int, Set, String)
     * @see    BackupTablesAck
     */
    public void backupTables(int roundID, Set tableNames, String comment, ResponseWaiter waiter) {
        addWaiter(BackupTablesAck.class, new InternalWaiter(waiter));
        sender.sendBackupTables(roundID, tableNames, comment);
    }


    /**
     * Gets the response to request for list of existing backup copies for
     * requested round. It is a responsibility of invoker of this method
     * to call it in appropriate time, namely this method should be invoked
     * after notification on response arrival.<p>
     * After invocation of this method the value of <code>
     * backupCopiesResponse</code> variable should be nullified.
     *
     * @return a GetBackupCopiesResponse containing the List of BackupCopy
     *         objects representing existing backup copies for specified
     *         round
     * @since  Admin Tool 2.0
     * @see    GetBackupCopiesResponse
     * @see    #backupCopiesResponse
     */
    public GetBackupCopiesResponse getBackupCopiesResponse() {
        return backupCopiesResponse;
    }


    /**
     * Sends the request for list of existing backup copies for specified
     * round to Admin Listener server. To do so registers specified waiter
     * to receive notifications on <code>GetBackupCopiesResponse</code> arrival
     * and invokes <code>CommandSender.sendGetBackupCopies(int)</code> method.
     *
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request becomes available.
     * @since  Admin Tool 2.0
     * @see    CommandSender#sendGetBackupCopies(int)
     * @see    GetBackupCopiesResponse
     */
    public void getBackupCopies(int roundID, ResponseWaiter waiter) {
        addWaiter(GetBackupCopiesResponse.class, new InternalWaiter(waiter));
        sender.sendGetBackupCopies(roundID);
    }


    /**
     * Sends the request for restore specified tables from specified backup copy
     * to Admin Listener server. To do so registers specified waiter
     * to receive notifications on <code>RestoreTablesAck</code> arrival
     * and invokes <code>CommandSender.sendRestoreTables(int, Set)</code> method.
     *
     * @param  backupID an ID of backup copy to restore tables from
     * @param  tableNames a Set of String names of tables to restore
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request becomes available.
     *
     * @throws IllegalArgumentException if given Set is null
     *
     * @since  Admin Tool 2.0
     *
     * @see    CommandSender#sendRestoreTables(int, Set)
     * @see    RestoreTablesAck
     */
    public void restoreTables(int backupID, Set tableNames, ResponseWaiter waiter) {
        addWaiter(RestoreTablesAck.class, new InternalWaiter(waiter));
        sender.sendRestoreTables(backupID, tableNames);
    }

    /**
     * Sends the request to perform a warehouse data load process specified by
     * requestID, Hashtable containing parameters and their values. Accepts
     * optional ResponseWaiter that should be notified when response to request
     * will arrive. Registers specified waiter to receive notifications on
     * WarehouseLoadAck arrival and invokes
     * CommandSender.sendPerformWarehouseLoad(int, Hashtable) method.
     *
     * @param requestID an ID of warehouse load request that should be used to
     * check the permission of requestor to perform such action. Also this ID
     * is used to determine the name of TCLoad class that should be used to
     * perform the warehouse load process.
     * @param params a Hashtable mapping parameter names to parameter values.
     * These parameters should be used to configure TCLoad class before
     * performing the load.
     * @param waiter a ResponseWaiter that should be notified when response to
     * request will arrive
     * @since Admin Tool 2.0
     * @see WarehouseLoadAck
     * @see CommandSender#sendPerformWarehouseLoad(int, Hashtable)
     */
    public void performWarehouseLoad(int requestID, Hashtable params, ResponseWaiter waiter) {
        addWaiter(WarehouseLoadAck.class, new InternalWaiter(waiter), LONG_TIMEOUT_MS);
        sender.sendPerformWarehouseLoad(requestID, params);
    }

    /**
     * Sends a request to restart specified service (compilers or testers) to
     * Admin Listener.  To do so registers specified waiter to receive
     * notifications on <code>RestartServiceAck</code> arrival and invokes
     * <code>CommandSender.sendRestartService(int)</code>
     * method.
     *
     * @param  serviceType a type of service to restart
     * @param  waiter a ResponseWaiter to be notified when the response to
     *         request to restart service becomes available.
     * @since Admin Tool 2.0
     * @see   RestartServiceAck
     * @see   com.topcoder.server.AdminListener.AdminConstants#REQUEST_RESTART_ALL
     * @see   com.topcoder.server.AdminListener.AdminConstants#REQUEST_RESTART_COMPILERS
     * @see   com.topcoder.server.AdminListener.AdminConstants#REQUEST_RESTART_TESTERS
     */
    public void restartService(int serviceType, int restartMode, ResponseWaiter waiter) {
        addWaiter(RestartServiceAck.class, new InternalWaiter(waiter));
        sender.sendRestartService(serviceType,restartMode);
    }
}

