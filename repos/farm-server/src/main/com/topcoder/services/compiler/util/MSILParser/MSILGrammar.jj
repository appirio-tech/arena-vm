/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\MSILGrammar.jj */
/*@egen*//**
* MSIL Grammar file
*/
options {                              
  STATIC=false;
}

PARSER_BEGIN(MSILParser)
package com.topcoder.services.compiler.util.MSILParser;

public class MSILParser/*@bgen(jjtree)*/implements MSILParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTMSILParserState jjtree = new JJTMSILParserState();

/*@egen*/
	public static void main(String args[]) throws ParseException {
		MSILParser parser = new MSILParser(System.in);
		long start = System.currentTimeMillis();
		SimpleNode node = parser.ILFile();
		long end = System.currentTimeMillis();
		node.dump("");
		System.out.println("\nParsed file in " + (end - start) + "ms");
	}
}
PARSER_END(MSILParser)

/* WHITE SPACE */

SKIP :
{
 " " | "\t" | "\f"
 | "\u001a" { System.out.println("Warning: cntl-z found at end of file"); }: IN_ONLY_EOF
}

<IN_ONLY_EOF>
MORE :
{
    < ~[]  > { System.out.println("Error: no characters should follow cntl-z at end of file"); }
}

SPECIAL_TOKEN :
{
  "\n"
| "\r"
| "\r\n"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN : { <SINGLE_LINE_COMMENT:  (~["\r","\n","\u001a"])* ("\r"|"\n"|"\r\n")? > : DEFAULT }

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* WORDS THAT START with "." */
TOKEN:
{
    <LINE: ".line" >
|
    <ASSEMBLY: ".assembly">
|  
    <CLASS: ".class">
|
    <CORFLAGS: ".corflags">
|
    <CUSTOM: ".custom" >
|
    <DATA: ".data">
|
    <FIELD: ".field">
|
    <FILE: ".file">
|
    <HASH: ".hash">
|
    <ENTRYPOINT: ".entrypoint">
|
    <METHOD: ".method" >
|
    <MODULE: ".module" >
|
    <MRESOURCE: ".mresource" >
|
    <SUBSYSTEM: ".subsystem">
|
    <VTFIXUP: ".vtfixup">
|
    <ALIGNMENT: "alignment">
|
    <IMAGEBASE: ".imagebase">
|
    <LANGUAGE: ".language">
|
    <NAMESPACE: ".namespace">
|
    <CULTURE: ".culture">
|
    <PUBLICKEY: ".publickey">
|
    <VER: ".ver">
|
    <PUBLICKEYTOKEN: ".publickeytoken" >
|
    <EVENT: ".event">
|
    <OVERRIDE: ".override">
|
    <PACK: ".pack">
|
    <PARAM: ".param">
|
    <PROPERTY: ".property">
|
    <SIZE: ".size">
|
    <EMITBYTE: ".emitbyte">
|
    <LOCALS: ".locals">
|
    <MAXSTACK: ".maxstack">
|
    <GET: ".get">
|
    <SET: ".set">
|
    <OTHER: ".other">
|
    <ADDON: ".addon">
|
    <FIRE: ".fire">
|
    <REMOVEON: ".removeon">
|
    <TRY: ".try">
|
    <PERMISSIONSET: ".permissionset">
|
    <PERMISSION: ".permission">
}

/* RESERVED WORDS */

TOKEN :
{
    <FLOAT32: "float32">
|
    <FLOAT64: "float64">
|
    <EXTERN: "extern">
|
    <NOMETADATA: "nometadata">
|
    <PUBLIC: "public">
|
    <PRIVATE: "private">
|
    <ALGORITHM: "algorithm">
|
    <AT: "at">
|
    <AS: "as">
|
    <IMPLEMENTS: "implements">
|
    <ABSTRACT: "abstract">
|
    <ANSI: "ansi">
|
    <AUTO: "auto">
|
    <AUTOCHAR: "autochar">
|
    <BEFOREFIELDINIT: "beforefieldinit">
|
    <EXPLICIT: "explicit">
|
    <INSTANCE: "instance">
|
    <INTERFACE: "interface">
|
    <NESTED: "nested">
|
    <ASSEMBLY_TYPE: "assembly">
|
    <FAMANDASSEM: "famandassem">
|
    <FAMILY: "family">
|
    <FAMORASSEM: "famorassem">
|
    <RTSPECIALNAME: "rtspecialname">
|
    <SEALED: "sealed">
|
    <SEQUENTIAL: "sequential">
|
    <SERIALIZABLE: "serializable">
|
    <SPECIALNAME: "specialname">
|
    <UNICODE: "unicode">
|
    <IMPORT: "import">
|
    <CTOR: ".ctor">
|
    <CCTOR: ".cctor">
|
    <EXTENDS: "extends">
|
    <WITH: "with">
|
    <TYPE: "type">
|
    <ELIPSES: "...">
|
    <DEFAULT_TOKEN: "default">
|
    <UNMANAGED: "unmanaged">
|
    <CDECL: "cdecl">
|
    <FASTCALL: "fastcall">
|
    <STDCALL: "stdcall">
|
    <THISCALL: "thiscall">
|
    <VARARG: "vararg">
|
    <MARSHAL: "marshal">
|
    <IN: "in">
|
    <OPT: "opt">
|
    <OUT: "out">
|
    <INIT: "init">
|
    <COMPILERCONTROLLED: "compilercontrolled">
|
    <FINAL: "final">
|
    <NEWSLOT: "newslot">
|
    <PINVOKEIMPL: "pinvokeimpl">
|
    <HIDEBYSIG: "hidebysig">
|
    <STATIC: "static">
|
    <VIRTUAL: "virtual">
|
    <STRICT: "strict">
|
    <CIL: "cil">
|
    <FORWARDREF: "forwardref">
|
    <INTERNALCALL: "internalcall">
|
    <MANAGED: "managed">
|
    <NOINLINING: "noinlining">
|
    <RUNTIME: "runtime">
|
    <SYNCHRONIZED: "synchronized">
|
    <FROMUNMANAGED: "fromunmanaged">
|
    <PLATFORMAPI: "platformapi">
|
    <INITONLY: "initonly">
|
    <LITERAL: "literal">
|
    <NOTSERIALIZED: "notserialized">
|
    <TRUE: "true">
|
    <FALSE: "false">
|
    <CATCH: "catch">
|
    <FAULT: "fault">
|
    <FINALLY: "finally">
|
    <FILTER: "filter">
|
    <TO: "to">
|
    <HANDLER: "handler">
|
    <ASSERT: "assert">
|
    <DEMAND: "demand">
|
    <DENY: "deny">
|
    <INHERITCHECK: "inheritcheck">
|
    <LINKCHECK: "linkcheck">
|
    <PERMITONLY: "permitonly">
|
    <REQOPT: "reqopt">
|
    <REQREFUSE: "reqrefuse">
|
    <REQUEST: "request">
}

/* TYPE TOKENS */
TOKEN :
{
    <BOOL_TYPE: "bool">
|
    <CHAR_TYPE: "char">
|
    <CLASS_TYPE: "class">
|
    <UINT8_TYPE: "uint8">
|
    <UINT16_TYPE: "uint16">
|
    <UINT32_TYPE: "uint32">
|
    <UINT64_TYPE: "uint64">
|
    <INT8_TYPE: "int8">
|
    <INT16_TYPE: "int16">
|
    <INT32_TYPE: "int32">
|
    <INT64_TYPE: "int64">
|
    <NATIVE: "native">
|
    <UNSIGNED: "unsigned">
|
    <INT_TYPE: "int">
|
    <OBJECT_TYPE: "object">
|
    <STRING_TYPE: "string">
|
    <MODOPT: "modopt">
|
    <MODREQ: "modreq">
|
    <PINNED: "pinned">
|
    <TYPEDREF: "typedref">
|
    <VALUETYPE: "valuetype">
|
    <VOID_TYPE: "void">
|
    <METHOD_TYPE: "method">
|
    <LPSTR: "lpstr">
|
    <LPWSTR: "lpwstr">
|
    <ANY: "any">
|
    <BYVALSTR: "byvalstr">
|
    <CUSTOM_TYPE: "custom">
|
    <FIXED: "fixed">
|
    <ARRAY: "array">
|
    <SYSSTRING: "sysstring">
|
    <LPSTRUCT: "lpstruct">
|
    <LPTSTR: "lptstr">
|
    <STRUCT: "struct">
|
    <BOXED: "boxed">
|
    <BYTEARRAY: "bytearray">
|
    <NULLREF: "nullref">
}

/* IMPORTANT TOKENS */
TOKEN :
{
    <DOT: ".">
|
    <COMMA: ",">
|
    <COLON: ":">
|
    <LEFT_PAREN: "(">
|
    <RIGHT_PAREN: ")">
|
    <LEFT_BRACE: "{">
|
    <RIGHT_BRACE: "}">
|
    <EQUALS: "=">
|
    <NOT: "!">
|
    <DOUBLENOT: "!!">
|
    <LEFT_BRACKET: "[">
|
    <RIGHT_BRACKET: "]">
|
    <LESS_THAN: "<">
|
    <GREATER_THAN: ">">
|
    <AMP: "&">
|
    <ASTERISK: "*">
|
    <SLASH: "/">
|
    <PLUS: "+">
|
    <MINUS: "-">
|
    <DOUBLE_COLON: "::">
}

/* Grammar follows */
SimpleNode ILFile() :
{/*@bgen(jjtree) ILFile */
  ASTILFile jjtn000 = new ASTILFile(JJTILFILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ILFile */
    try {
/*@egen*/
    (Decl())*
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Id() :
{/*@bgen(jjtree) Id */
    ASTId jjtn000 = new ASTId(JJTID);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) Id */
    try {
/*@egen*/
    (t=<ID> | t=<SQSTRING> | t=<HEX_VALID_ID>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DottedName() :
{/*@bgen(jjtree) DottedName */
    ASTDottedName jjtn000 = new ASTDottedName(JJTDOTTEDNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) DottedName */
    try {
/*@egen*/
    (t=<DOTTED_NAME> | Id())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
        if(t != null) jjtn000.setName(t.image); 
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LabelOrOffset() :
{/*@bgen(jjtree) LabelOrOffset */
  ASTLabelOrOffset jjtn000 = new ASTLabelOrOffset(JJTLABELOROFFSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LabelOrOffset */
    try {
/*@egen*/
    Id()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Labels() :
{/*@bgen(jjtree) Labels */
  ASTLabels jjtn000 = new ASTLabels(JJTLABELS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Labels */
    try {
/*@egen*/
    LabelOrOffset() (<COMMA> LabelOrOffset())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void CodeLabel() :
{/*@bgen(jjtree) CodeLabel */
  ASTCodeLabel jjtn000 = new ASTCodeLabel(JJTCODELABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CodeLabel */
    try {
/*@egen*/
    Id() <COLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DataLabel() :
{/*@bgen(jjtree) DataLabel */
  ASTDataLabel jjtn000 = new ASTDataLabel(JJTDATALABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DataLabel */
    try {
/*@egen*/
    Id()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bytes() :
{/*@bgen(jjtree) Bytes */
  ASTBytes jjtn000 = new ASTBytes(JJTBYTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bytes */
    try {
/*@egen*/
    HexByte() ( HexByte() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void Float32() :
{/*@bgen(jjtree) Float32 */
  ASTFloat32 jjtn000 = new ASTFloat32(JJTFLOAT32);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Float32 */
    try {
/*@egen*/
    RealNumber() | ( <FLOAT32> <LEFT_PAREN> Int32() <RIGHT_PAREN> )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Float64() :
{/*@bgen(jjtree) Float64 */
  ASTFloat64 jjtn000 = new ASTFloat64(JJTFLOAT64);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Float64 */
    try {
/*@egen*/
    RealNumber() | ( <FLOAT32> <LEFT_PAREN> Int32() <RIGHT_PAREN> )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExternSourceDecl() :
{/*@bgen(jjtree) ExternSourceDecl */
  ASTExternSourceDecl jjtn000 = new ASTExternSourceDecl(JJTEXTERNSOURCEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExternSourceDecl */
    try {
/*@egen*/
    LOOKAHEAD(4)
    (<LINE> Int32() [ LOOKAHEAD(2) (<COLON> Int32()) ] [LOOKAHEAD(2) <SQSTRING> ]) |
    (<LINE> Int32() <QSTRING> )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Filename() : 
{/*@bgen(jjtree) Filename */
  ASTFilename jjtn000 = new ASTFilename(JJTFILENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Filename */
    try {
/*@egen*/
    DottedName()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//basic tree item

void Decl() :
{/*@bgen(jjtree) Decl */
  ASTDecl jjtn000 = new ASTDecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Decl */
    try {
/*@egen*/
    LOOKAHEAD(2)
    (<ASSEMBLY> DottedName() <LEFT_BRACE> (AsmDecl())* <RIGHT_BRACE> ) |
    (<ASSEMBLY> <EXTERN> DottedName() [<AS> DottedName()] <LEFT_BRACE> (AsmRefDecl())* <RIGHT_BRACE>) |
    LOOKAHEAD(2)/*@bgen(jjtree) Class */
    {
      ASTClass jjtn001 = new ASTClass(JJTCLASS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<CLASS> ClassHeader() <LEFT_BRACE> (ClassMember())* <RIGHT_BRACE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |
    (<CLASS> <EXTERN> ExportAttr() DottedName() <LEFT_BRACE> (ExternClassDecl())* <RIGHT_BRACE>) |
    (<CORFLAGS> Int32()) |
    (<CUSTOM> CustomDecl()) |
    (<DATA> DataDecl()) |
    (<FIELD> FieldDecl()) |
    LOOKAHEAD(2)
    (<FILE> [<NOMETADATA>] Filename() <HASH> <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN> [<ENTRYPOINT>]) |
    (<METHOD> MethodHeader() <LEFT_BRACE> (MethodBodyItem())* <RIGHT_BRACE>) |
    LOOKAHEAD(2)
    (<MODULE> <EXTERN> Filename()) |
    (<MODULE> [Filename()]) |
    (<MRESOURCE> [ (<PUBLIC> | <PRIVATE>) ] DottedName() <LEFT_BRACE> (ManResDecl())* <RIGHT_BRACE>) |
    (<SUBSYSTEM> Int32()) |
    (<VTFIXUP> VTFixupDecl()) |
    (ExternSourceDecl()) |
    (SecurityDecl()) |
    (<FILE> <ALIGNMENT> Int32()) |
    (<IMAGEBASE> Int32()) |
    (<LANGUAGE> LanguageDecl()) |
    (<NAMESPACE> Id()) |
    (<".stackreserve"> Int32())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LanguageDecl() :
{/*@bgen(jjtree) LanguageDecl */
  ASTLanguageDecl jjtn000 = new ASTLanguageDecl(JJTLANGUAGEDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LanguageDecl */
    try {
/*@egen*/
    <SQSTRING> [<COMMA> <SQSTRING> [<COMMA> <SQSTRING>]]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SecurityDecl() :
{/*@bgen(jjtree) SecurityDecl */
  ASTSecurityDecl jjtn000 = new ASTSecurityDecl(JJTSECURITYDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SecurityDecl */
    try {
/*@egen*/
    (<PERMISSIONSET> SecAction() <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<PERMISSION> SecAction() TypeReference() <LEFT_PAREN> NameValPairs() <RIGHT_PAREN>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NameValPairs():
{/*@bgen(jjtree) NameValPairs */
  ASTNameValPairs jjtn000 = new ASTNameValPairs(JJTNAMEVALPAIRS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NameValPairs */
    try {
/*@egen*/
    NameValPair() (<COMMA> NameValPair())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NameValPair():
{/*@bgen(jjtree) NameValPair */
  ASTNameValPair jjtn000 = new ASTNameValPair(JJTNAMEVALPAIR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NameValPair */
    try {
/*@egen*/
    <SQSTRING> <EQUALS> <SQSTRING>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SecAction():
{/*@bgen(jjtree) SecAction */
  ASTSecAction jjtn000 = new ASTSecAction(JJTSECACTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SecAction */
    try {
/*@egen*/
    <ASSERT> |
    <DEMAND> |
    <DENY> |
    <INHERITCHECK> |
    <LINKCHECK> |
    <PERMITONLY> |
    <REQOPT> |
    <REQREFUSE> |
    <REQUEST>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VTFixupDecl() :
{/*@bgen(jjtree) VTFixupDecl */
  ASTVTFixupDecl jjtn000 = new ASTVTFixupDecl(JJTVTFIXUPDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VTFixupDecl */
    try {
/*@egen*/
    [Int32()] (VTFixupAttr())* <AT> DataLabel()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VTFixupAttr():
{/*@bgen(jjtree) VTFixupAttr */
  ASTVTFixupAttr jjtn000 = new ASTVTFixupAttr(JJTVTFIXUPATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VTFixupAttr */
    try {
/*@egen*/
    <FROMUNMANAGED> | <INT32_TYPE> | <INT64_TYPE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ManResDecl() :
{/*@bgen(jjtree) ManResDecl */
  ASTManResDecl jjtn000 = new ASTManResDecl(JJTMANRESDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ManResDecl */
    try {
/*@egen*/
    (<ASSEMBLY> <EXTERN> DottedName()) |
    (<CUSTOM> CustomDecl()) |
    (<FILE> DottedName() <AT> Int32())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void LocalsSignature():
{/*@bgen(jjtree) LocalsSignature */
  ASTLocalsSignature jjtn000 = new ASTLocalsSignature(JJTLOCALSSIGNATURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LocalsSignature */
    try {
/*@egen*/
    Local() (<COMMA> Local())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Local():
{/*@bgen(jjtree) Local */
  ASTLocal jjtn000 = new ASTLocal(JJTLOCAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Local */
    try {
/*@egen*/
    [<LEFT_BRACKET> Int32() <RIGHT_BRACKET>] Type() [Id()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Instr():
{/*@bgen(jjtree) Instr */
  ASTInstr jjtn000 = new ASTInstr(JJTINSTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr */
    try {
/*@egen*/
    (Instr_None()) |
    LOOKAHEAD(2)
    (Instr_Var() Int32()) |
    (Instr_Var() DottedName()) |
    (Instr_I() Int32()) |
    LOOKAHEAD(2)
    (Instr_R() Float64()) |
    LOOKAHEAD(2)
    (Instr_R() Int32()) |
    (Instr_R() <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    (Instr_Br() Int32()) |
    (Instr_Br() DataLabel()) |
    (Instr_Method() CallConv() Type()/*@bgen(jjtree) MethodCall */
                                      {
                                        ASTMethodCall jjtn001 = new ASTMethodCall(JJTMETHODCALL);
                                        boolean jjtc001 = true;
                                        jjtree.openNodeScope(jjtn001);
                                      }
                                      try {
/*@egen*/ ([LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName())/*@bgen(jjtree)*/
                                      } catch (Throwable jjte001) {
                                        if (jjtc001) {
                                          jjtree.clearNodeScope(jjtn001);
                                          jjtc001 = false;
                                        } else {
                                          jjtree.popNode();
                                        }
                                        if (jjte001 instanceof RuntimeException) {
                                          throw (RuntimeException)jjte001;
                                        }
                                        if (jjte001 instanceof ParseException) {
                                          throw (ParseException)jjte001;
                                        }
                                        throw (Error)jjte001;
                                      } finally {
                                        if (jjtc001) {
                                          jjtree.closeNodeScope(jjtn001, true);
                                        }
                                      }
/*@egen*/ [<LESS_THAN> GenArgs() <GREATER_THAN>] <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (Instr_Field() Type() TypeSpec() <DOUBLE_COLON> Id()) |
    (Instr_Type() TypeSpec()) |
    LOOKAHEAD(2)
    (<"ldstr"> <QSTRING>) |
    (<"ldstr"> <BYTEARRAY> <LEFT_PAREN> Bytes() <RIGHT_PAREN> ) |
    (<"calli"> CallConv() Type() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    (Instr_Tok() TypeSpec()) |
    LOOKAHEAD(2)
    (Instr_Tok() <METHOD_TYPE> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() [<LESS_THAN> GenArgs() <GREATER_THAN>] <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (Instr_Tok() <"field"> Type() TypeSpec() <DOUBLE_COLON> Id()) |
    (<"switch"> <LEFT_PAREN> Labels() <RIGHT_PAREN>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Instr_Tok():
{/*@bgen(jjtree) Instr_Tok */
  ASTInstr_Tok jjtn000 = new ASTInstr_Tok(JJTINSTR_TOK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Tok */
    try {
/*@egen*/
    <"ldtoken">/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

TOKEN : {
	<OP_BOX: "box"> |
	<OP_CASTCLASS: "castclass"> |
	<OP_CPOBJ: "cpobj"> |
	<OP_INITOBJ: "initobj"> |
	<OP_ISINST: "isinst"> |
        <OP_LDELEM: "ldelem"> |
	<OP_LDELEMA: "ldelema"> |
	<OP_LDOBJ: "ldobj"> |
	<OP_MKREFANY: "mkrefany"> |
	<OP_NEWARR: "newarr"> |
	<OP_REFANYVAL: "refanyval"> |
	<OP_SIZEOF: "sizeof"> |
	<OP_STOBJ: "stobj"> |
	<OP_UNBOX: "unbox"> |
        <OP_UNBOXANY: "unbox.any"> |
        <OP_BOXANY: "box.any"> |
        <OP_CONSTRAINED: "constrained."> |
        <OP_STELEM: "stelem">
}

void Instr_Type():
{/*@bgen(jjtree) Instr_Type */
  ASTInstr_Type jjtn000 = new ASTInstr_Type(JJTINSTR_TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Type */
        try {
/*@egen*/
    	(<OP_BOX>)|
	(<OP_CASTCLASS>)|
	(<OP_CPOBJ>)|
	(<OP_INITOBJ>)|
	(<OP_ISINST>)|
        (<OP_LDELEM>)|
	(<OP_LDELEMA>)|
	(<OP_LDOBJ>)|
	(<OP_MKREFANY>)|
	(<OP_NEWARR>)|
	(<OP_REFANYVAL>)|
	(<OP_SIZEOF>)|
	(<OP_STOBJ>)|
	(<OP_UNBOX>)|
	(<OP_UNBOXANY>)|
	(<OP_BOXANY>)|
        (<OP_CONSTRAINED>) |
        (<OP_STELEM>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}   

TOKEN : {
	<OP_LDFLD: "ldfld"> |
	<OP_LDFLDA: "ldflda"> |
	<OP_LDSFLD: "ldsfld"> |
	<OP_LDSFLDA: "ldsflda"> |
	<OP_STFLD: "stfld"> |
	<OP_STSFLD: "stsfld">
}

void Instr_Field():
{/*@bgen(jjtree) Instr_Field */
  ASTInstr_Field jjtn000 = new ASTInstr_Field(JJTINSTR_FIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Field */
        try {
/*@egen*/
	(<OP_LDFLD>)|
	(<OP_LDFLDA>)|
	(<OP_LDSFLD>)|
	(<OP_LDSFLDA>)|
	(<OP_STFLD>)|
	(<OP_STSFLD>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


TOKEN : {
	<OP_CALL: "call"> |
	<OP_CALLVIRT: "callvirt"> |
	<OP_JMP: "jmp"> |
	<OP_LDFTN: "ldftn"> |
	<OP_LDVIRTFTN: "ldvirtftn"> |
	<OP_NEWOBJ: "newobj">
}

void Instr_Method():
{/*@bgen(jjtree) Instr_Method */
  ASTInstr_Method jjtn000 = new ASTInstr_Method(JJTINSTR_METHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Method */
        try {
/*@egen*/
	(<OP_CALL>)|
	(<OP_CALLVIRT>)|
	(<OP_JMP>)|
	(<OP_LDFTN>)|
	(<OP_LDVIRTFTN>)|
	(<OP_NEWOBJ>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TOKEN : {
	<OP_BEQ: "beq"> |
	<OP_BEQDOTS: "beq.s"> |
	<OP_BGE: "bge"> |
	<OP_BGEDOTS: "bge.s"> |
	<OP_BGEDOTUN: "bge.un"> |
	<OP_BGEDOTUNDOTS: "bge.un.s"> |
	<OP_BGT: "bgt"> |
	<OP_BGTDOTS: "bgt.s"> |
	<OP_BGTDOTUN: "bgt.un"> |
	<OP_BGTDOTUNDOTS: "bgt.un.s"> |
	<OP_BLE: "ble"> |
	<OP_BLEDOTS: "ble.s"> |
	<OP_BLEDOTUN: "ble.un"> |
	<OP_BLEDOTUNDOTS: "ble.un.s"> |
	<OP_BLT: "blt"> |
	<OP_BLTDOTS: "blt.s"> |
	<OP_BLTDOTUN: "blt.un"> |
	<OP_BLTDOTUNDOTS: "blt.un.s"> |
	<OP_BNEDOTUN: "bne.un"> |
	<OP_BNEDOTUNDOTS: "bne.un.s"> |
	<OP_BR: "br"> |
	<OP_BRDOTS: "br.s"> |
	<OP_BRFALSE: "brfalse"> |
	<OP_BRFALSEDOTS: "brfalse.s"> |
	<OP_BRTRUE: "brtrue"> |
	<OP_BRTRUEDOTS: "brtrue.s"> |
	<OP_LEAVE: "leave"> |
	<OP_LEAVEDOTS: "leave.s"> 
}

void Instr_Br():
{/*@bgen(jjtree) Instr_Br */
  ASTInstr_Br jjtn000 = new ASTInstr_Br(JJTINSTR_BR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Br */
        try {
/*@egen*/
	(<OP_BEQ>)|
	(<OP_BEQDOTS>)|
	(<OP_BGE>)|
	(<OP_BGEDOTS>)|
	(<OP_BGEDOTUN>)|
	(<OP_BGEDOTUNDOTS>)|
	(<OP_BGT>)|
	(<OP_BGTDOTS>)|
	(<OP_BGTDOTUN>)|
	(<OP_BGTDOTUNDOTS>)|
	(<OP_BLE>)|
	(<OP_BLEDOTS>)|
	(<OP_BLEDOTUN>)|
	(<OP_BLEDOTUNDOTS>)|
	(<OP_BLT>)|
	(<OP_BLTDOTS>)|
	(<OP_BLTDOTUN>)|
	(<OP_BLTDOTUNDOTS>)|
	(<OP_BNEDOTUN>)|
	(<OP_BNEDOTUNDOTS>)|
	(<OP_BR>)|
	(<OP_BRDOTS>)|
	(<OP_BRFALSE>)|
	(<OP_BRFALSEDOTS>)|
	(<OP_BRTRUE>)|
	(<OP_BRTRUEDOTS>)|
	(<OP_LEAVE>)|
	(<OP_LEAVEDOTS>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TOKEN : {
	<OP_LDCDOTR4: "ldc.r4"> |
	<OP_LDCDOTR8: "ldc.r8">
}

void Instr_R():
{/*@bgen(jjtree) Instr_R */
  ASTInstr_R jjtn000 = new ASTInstr_R(JJTINSTR_R);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_R */
        try {
/*@egen*/
	(<OP_LDCDOTR4>)|
	(<OP_LDCDOTR8>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}   

TOKEN : {
	<OP_LDCDOTI4: "ldc.i4"> |
        <OP_LDCDOTI8: "ldc.i8"> |
	<OP_LDCDOTI4DOTS: "ldc.i4.s"> |
	<OP_UNALIGNEDDOT: "unaligned.">
}

void Instr_I():
{/*@bgen(jjtree) Instr_I */
  ASTInstr_I jjtn000 = new ASTInstr_I(JJTINSTR_I);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_I */
        try {
/*@egen*/
	(<OP_LDCDOTI4>)|
	(<OP_LDCDOTI4DOTS>)|
	(<OP_UNALIGNEDDOT>) |
        (<OP_LDCDOTI8>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TOKEN : {
	<OP_LDARG: "ldarg"> |
	<OP_LDARGDOTS: "ldarg.s"> |
	<OP_LDARGA: "ldarga"> |
	<OP_LDARGADOTS: "ldarga.s"> |
	<OP_LDLOC: "ldloc"> |
	<OP_LDLOCDOTS: "ldloc.s"> |
	<OP_LDLOCA: "ldloca"> |
	<OP_LDLOCADOTS: "ldloca.s"> |
	<OP_STARG: "starg"> |
	<OP_STARGDOTS: "starg.s"> |
	<OP_STLOC: "stloc"> |
	<OP_STLOCDOTS: "stloc.s">
}

void Instr_Var():
{/*@bgen(jjtree) Instr_Var */
  ASTInstr_Var jjtn000 = new ASTInstr_Var(JJTINSTR_VAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_Var */
        try {
/*@egen*/
	(<OP_LDARG>)|
	(<OP_LDARGDOTS>)|
	(<OP_LDARGA>)|
	(<OP_LDARGADOTS>)|
	(<OP_LDLOC>)|
	(<OP_LDLOCDOTS>)|
	(<OP_LDLOCA>)|
	(<OP_LDLOCADOTS>)|
	(<OP_STARG>)|
	(<OP_STARGDOTS>)|
	(<OP_STLOC>)|
	(<OP_STLOCDOTS>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

TOKEN : 
{
	<OP_ADD: "add"> |
	<OP_ADDDOTOVF: "add.ovf"> |
	<OP_ADDDOTOVFDOTUN: "add.ovf.un"> |
	<OP_AND: "and"> |
	<OP_ARGLIST: "arglist"> |
	<OP_BREAK: "break"> |
	<OP_CEQ: "ceq"> |
	<OP_CGT: "cgt"> |
	<OP_CGTDOTUN: "cgt.un"> |
	<OP_CKFINITE: "ckfinite"> |
	<OP_CLT: "clt"> |
	<OP_CLTDOTUN: "clt.un"> |
	<OP_CONVDOTI: "conv.i"> |
	<OP_CONVDOTI1: "conv.i1"> |
	<OP_CONVDOTI2: "conv.i2"> |
	<OP_CONVDOTI4: "conv.i4"> |
	<OP_CONVDOTI8: "conv.i8"> |
	<OP_CONVDOTOVFDOTI: "conv.ovf.i"> |
	<OP_CONVDOTOVFDOTIDOTUN: "conv.ovf.i.un"> |
	<OP_CONVDOTOVFDOTI1: "conv.ovf.i1"> |
	<OP_CONVDOTOVFDOTI1DOTUN: "conv.ovf.i1.un"> |
	<OP_CONVDOTOVFDOTI2: "conv.ovf.i2"> |
	<OP_CONVDOTOVFDOTI2DOTUN: "conv.ovf.i2.un"> |
	<OP_CONVDOTOVFDOTI4: "conv.ovf.i4"> |
	<OP_CONVDOTOVFDOTI4DOTUN: "conv.ovf.i4.un"> |
	<OP_CONVDOTOVFDOTI8: "conv.ovf.i8"> |
	<OP_CONVDOTOVFDOTI8DOTUN: "conv.ovf.i8.un"> |
	<OP_CONVDOTOVFDOTU: "conv.ovf.u"> |
	<OP_CONVDOTOVFDOTUDOTUN: "conv.ovf.u.un"> |
	<OP_CONVDOTOVFDOTU1: "conv.ovf.u1"> |
	<OP_CONVDOTOVFDOTU1DOTUN: "conv.ovf.u1.un"> |
	<OP_CONVDOTOVFDOTU2: "conv.ovf.u2"> |
	<OP_CONVDOTOVFDOTU2DOTUN: "conv.ovf.u2.un"> |
	<OP_CONVDOTOVFDOTU4: "conv.ovf.u4"> |
	<OP_CONVDOTOVFDOTU4DOTUN: "conv.ovf.u4.un"> |
	<OP_CONVDOTOVFDOTU8: "conv.ovf.u8"> |
	<OP_CONVDOTOVFDOTU8DOTUN: "conv.ovf.u8.un"> |
	<OP_CONVDOTRDOTUN: "conv.r.un"> |
	<OP_CONVDOTR4: "conv.r4"> |
	<OP_CONVDOTR8: "conv.r8"> |
	<OP_CONVDOTU: "conv.u"> |
	<OP_CONVDOTU1: "conv.u1"> |
	<OP_CONVDOTU2: "conv.u2"> |
	<OP_CONVDOTU4: "conv.u4"> |
	<OP_CONVDOTU8: "conv.u8"> |
	<OP_CPBLK: "cpblk"> |
	<OP_DIV: "div"> |
	<OP_DIVDOTUN: "div.un"> |
	<OP_DUP: "dup"> |
	<OP_ENDFAULT: "endfault"> |
	<OP_ENDFILTER: "endfilter"> |
	<OP_ENDFINALLY: "endfinally"> |
	<OP_INITBLK: "initblk"> |
	<OP_LDARGDOT0: "ldarg.0"> |
	<OP_LDARGDOT1: "ldarg.1"> |
	<OP_LDARGDOT2: "ldarg.2"> |
	<OP_LDARGDOT3: "ldarg.3"> |
	<OP_LDCDOTI4DOT0: "ldc.i4.0"> |
	<OP_LDCDOTI4DOT1: "ldc.i4.1"> |
	<OP_LDCDOTI4DOT2: "ldc.i4.2"> |
	<OP_LDCDOTI4DOT3: "ldc.i4.3"> |
	<OP_LDCDOTI4DOT4: "ldc.i4.4"> |
	<OP_LDCDOTI4DOT5: "ldc.i4.5"> |
	<OP_LDCDOTI4DOT6: "ldc.i4.6"> |
	<OP_LDCDOTI4DOT7: "ldc.i4.7"> |
	<OP_LDCDOTI4DOT8: "ldc.i4.8"> |
	<OP_LDCDOTI4DOTM1: "ldc.i4.m1"> |
	<OP_LDELEMDOTI: "ldelem.i"> |
	<OP_LDELEMDOTI1: "ldelem.i1"> |
	<OP_LDELEMDOTI2: "ldelem.i2"> |
	<OP_LDELEMDOTI4: "ldelem.i4"> |
	<OP_LDELEMDOTI8: "ldelem.i8"> |
	<OP_LDELEMDOTR4: "ldelem.r4"> |
	<OP_LDELEMDOTR8: "ldelem.r8"> |
	<OP_LDELEMDOTREF: "ldelem.ref"> |
	<OP_LDELEMDOTU1: "ldelem.u1"> |
	<OP_LDELEMDOTU2: "ldelem.u2"> |
	<OP_LDELEMDOTU4: "ldelem.u4"> |
	<OP_LDINDDOTI: "ldind.i"> |
	<OP_LDINDDOTI1: "ldind.i1"> |
	<OP_LDINDDOTI2: "ldind.i2"> |
	<OP_LDINDDOTI4: "ldind.i4"> |
	<OP_LDINDDOTI8: "ldind.i8"> |
	<OP_LDINDDOTR4: "ldind.r4"> |
	<OP_LDINDDOTR8: "ldind.r8"> |
	<OP_LDINDDOTREF: "ldind.ref"> |
	<OP_LDINDDOTU1: "ldind.u1"> |
	<OP_LDINDDOTU2: "ldind.u2"> |
	<OP_LDINDDOTU4: "ldind.u4"> |
	<OP_LDLEN: "ldlen"> |
	<OP_LDLOCDOT0: "ldloc.0"> |
	<OP_LDLOCDOT1: "ldloc.1"> |
	<OP_LDLOCDOT2: "ldloc.2"> |
	<OP_LDLOCDOT3: "ldloc.3"> |
	<OP_LDNULL: "ldnull"> |
	<OP_LOCALLOC: "localloc"> |
	<OP_MUL: "mul"> |
	<OP_MULDOTOVF: "mul.ovf"> |
	<OP_MULDOTOVFDOTUN: "mul.ovf.un"> |
	<OP_NEG: "neg"> |
	<OP_NOP: "nop"> |
	<OP_NOT: "not"> |
	<OP_OR: "or"> |
	<OP_POP: "pop"> |
	<OP_READONLY: "readonly."> |
	<OP_REFANYTYPE: "refanytype"> |
	<OP_REM: "rem"> |
	<OP_REMDOTUN: "rem.un"> |
	<OP_RET: "ret"> |
	<OP_RETHROW: "rethrow"> |
	<OP_SHL: "shl"> |
	<OP_SHR: "shr"> |
	<OP_SHRDOTUN: "shr.un"> |
	<OP_STELEMDOTI: "stelem.i"> |
	<OP_STELEMDOTI1: "stelem.i1"> |
	<OP_STELEMDOTI2: "stelem.i2"> |
	<OP_STELEMDOTI4: "stelem.i4"> |
	<OP_STELEMDOTI8: "stelem.i8"> |
	<OP_STELEMDOTR4: "stelem.r4"> |
	<OP_STELEMDOTR8: "stelem.r8"> |
	<OP_STELEMDOTREF: "stelem.ref"> |
	<OP_STINDDOTI: "stind.i"> |
	<OP_STINDDOTI1: "stind.i1"> |
	<OP_STINDDOTI2: "stind.i2"> |
	<OP_STINDDOTI4: "stind.i4"> |
	<OP_STINDDOTI8: "stind.i8"> |
	<OP_STINDDOTR4: "stind.r4"> |
	<OP_STINDDOTR8: "stind.r8"> |
	<OP_STINDDOTREF: "stind.ref"> |
	<OP_STLOCDOT0: "stloc.0"> |
	<OP_STLOCDOT1: "stloc.1"> |
	<OP_STLOCDOT2: "stloc.2"> |
	<OP_STLOCDOT3: "stloc.3"> |
	<OP_SUB: "sub"> |
	<OP_SUBDOTOVF: "sub.ovf"> |
	<OP_SUBDOTOVFDOTUN: "sub.ovf.un"> |
	<OP_TAILDOT: "tail."> |
	<OP_THROW: "throw"> |
	<OP_VOLATILEDOT: "volatile."> |
	<OP_XOR: "xor">
}

void Instr_None():
{/*@bgen(jjtree) Instr_None */
  ASTInstr_None jjtn000 = new ASTInstr_None(JJTINSTR_NONE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Instr_None */
        try {
/*@egen*/
	(<OP_ADD>)|
	(<OP_ADDDOTOVF>)|
	(<OP_ADDDOTOVFDOTUN>)|
	(<OP_AND>)|
	(<OP_ARGLIST>)|
	(<OP_BREAK>)|
	(<OP_CEQ>)|
	(<OP_CGT>)|
	(<OP_CGTDOTUN>)|
	(<OP_CKFINITE>)|
	(<OP_CLT>)|
	(<OP_CLTDOTUN>)|
	(<OP_CONVDOTI>)|
	(<OP_CONVDOTI1>)|
	(<OP_CONVDOTI2>)|
	(<OP_CONVDOTI4>)|
	(<OP_CONVDOTI8>)|
	(<OP_CONVDOTOVFDOTI>)|
	(<OP_CONVDOTOVFDOTIDOTUN>)|
	(<OP_CONVDOTOVFDOTI1>)|
	(<OP_CONVDOTOVFDOTI1DOTUN>)|
	(<OP_CONVDOTOVFDOTI2>)|
	(<OP_CONVDOTOVFDOTI2DOTUN>)|
	(<OP_CONVDOTOVFDOTI4>)|
	(<OP_CONVDOTOVFDOTI4DOTUN>)|
	(<OP_CONVDOTOVFDOTI8>)|
	(<OP_CONVDOTOVFDOTI8DOTUN>)|
	(<OP_CONVDOTOVFDOTU>)|
	(<OP_CONVDOTOVFDOTUDOTUN>)|
	(<OP_CONVDOTOVFDOTU1>)|
	(<OP_CONVDOTOVFDOTU1DOTUN>)|
	(<OP_CONVDOTOVFDOTU2>)|
	(<OP_CONVDOTOVFDOTU2DOTUN>)|
	(<OP_CONVDOTOVFDOTU4>)|
	(<OP_CONVDOTOVFDOTU4DOTUN>)|
	(<OP_CONVDOTOVFDOTU8>)|
	(<OP_CONVDOTOVFDOTU8DOTUN>)|
	(<OP_CONVDOTRDOTUN>)|
	(<OP_CONVDOTR4>)|
	(<OP_CONVDOTR8>)|
	(<OP_CONVDOTU>)|
	(<OP_CONVDOTU1>)|
	(<OP_CONVDOTU2>)|
	(<OP_CONVDOTU4>)|
	(<OP_CONVDOTU8>)|
	(<OP_CPBLK>)|
	(<OP_DIV>)|
	(<OP_DIVDOTUN>)|
	(<OP_DUP>)|
	(<OP_ENDFAULT>)|
	(<OP_ENDFILTER>)|
	(<OP_ENDFINALLY>)|
	(<OP_INITBLK>)|
	(<OP_LDARGDOT0>)|
	(<OP_LDARGDOT1>)|
	(<OP_LDARGDOT2>)|
	(<OP_LDARGDOT3>)|
	(<OP_LDCDOTI4DOT0>)|
	(<OP_LDCDOTI4DOT1>)|
	(<OP_LDCDOTI4DOT2>)|
	(<OP_LDCDOTI4DOT3>)|
	(<OP_LDCDOTI4DOT4>)|
	(<OP_LDCDOTI4DOT5>)|
	(<OP_LDCDOTI4DOT6>)|
	(<OP_LDCDOTI4DOT7>)|
	(<OP_LDCDOTI4DOT8>)|
	(<OP_LDCDOTI4DOTM1>)|
	(<OP_LDELEMDOTI>)|
	(<OP_LDELEMDOTI1>)|
	(<OP_LDELEMDOTI2>)|
	(<OP_LDELEMDOTI4>)|
	(<OP_LDELEMDOTI8>)|
	(<OP_LDELEMDOTR4>)|
	(<OP_LDELEMDOTR8>)|
	(<OP_LDELEMDOTREF>)|
	(<OP_LDELEMDOTU1>)|
	(<OP_LDELEMDOTU2>)|
	(<OP_LDELEMDOTU4>)|
	(<OP_LDINDDOTI>)|
	(<OP_LDINDDOTI1>)|
	(<OP_LDINDDOTI2>)|
	(<OP_LDINDDOTI4>)|
	(<OP_LDINDDOTI8>)|
	(<OP_LDINDDOTR4>)|
	(<OP_LDINDDOTR8>)|
	(<OP_LDINDDOTREF>)|
	(<OP_LDINDDOTU1>)|
	(<OP_LDINDDOTU2>)|
	(<OP_LDINDDOTU4>)|
	(<OP_LDLEN>)|
	(<OP_LDLOCDOT0>)|
	(<OP_LDLOCDOT1>)|
	(<OP_LDLOCDOT2>)|
	(<OP_LDLOCDOT3>)|
	(<OP_LDNULL>)|
	(<OP_LOCALLOC>)|
	(<OP_MUL>)|
	(<OP_MULDOTOVF>)|
	(<OP_MULDOTOVFDOTUN>)|
	(<OP_NEG>)|
	(<OP_NOP>)|
	(<OP_NOT>)|
	(<OP_OR>)|
	(<OP_POP>)|
	(<OP_READONLY>)|
	(<OP_REFANYTYPE>)|
	(<OP_REM>)|
	(<OP_REMDOTUN>)|
	(<OP_RET>)|
	(<OP_RETHROW>)|
	(<OP_SHL>)|
	(<OP_SHR>)|
	(<OP_SHRDOTUN>)|
	(<OP_STELEMDOTI>)|
	(<OP_STELEMDOTI1>)|
	(<OP_STELEMDOTI2>)|
	(<OP_STELEMDOTI4>)|
	(<OP_STELEMDOTI8>)|
	(<OP_STELEMDOTR4>)|
	(<OP_STELEMDOTR8>)|
	(<OP_STELEMDOTREF>)|
	(<OP_STINDDOTI>)|
	(<OP_STINDDOTI1>)|
	(<OP_STINDDOTI2>)|
	(<OP_STINDDOTI4>)|
	(<OP_STINDDOTI8>)|
	(<OP_STINDDOTR4>)|
	(<OP_STINDDOTR8>)|
	(<OP_STINDDOTREF>)|
	(<OP_STLOCDOT0>)|
	(<OP_STLOCDOT1>)|
	(<OP_STLOCDOT2>)|
	(<OP_STLOCDOT3>)|
	(<OP_SUB>)|
	(<OP_SUBDOTOVF>)|
	(<OP_SUBDOTOVFDOTUN>)|
	(<OP_TAILDOT>)|
	(<OP_THROW>)|
	(<OP_VOLATILEDOT>)|
	(<OP_XOR>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ScopeBlock():
{/*@bgen(jjtree) ScopeBlock */
  ASTScopeBlock jjtn000 = new ASTScopeBlock(JJTSCOPEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ScopeBlock */
    try {
/*@egen*/
    <LEFT_BRACE> (MethodBodyItem())* <RIGHT_BRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SEHBlock():
{/*@bgen(jjtree) SEHBlock */
  ASTSEHBlock jjtn000 = new ASTSEHBlock(JJTSEHBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SEHBlock */
    try {
/*@egen*/
    TryBlock() SEHClause() (SEHClause())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TryBlock():
{/*@bgen(jjtree) TryBlock */
  ASTTryBlock jjtn000 = new ASTTryBlock(JJTTRYBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TryBlock */
    try {
/*@egen*/
    LOOKAHEAD(2)
    (<TRY> DataLabel() <TO> DataLabel()) |
    (<TRY> ScopeBlock())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SEHClause():
{/*@bgen(jjtree) SEHClause */
  ASTSEHClause jjtn000 = new ASTSEHClause(JJTSEHCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SEHClause */
    try {
/*@egen*/
    (<CATCH> TypeReference() HandlerBlock()) |
    (<FAULT> HandlerBlock()) |
    (<FILTER> DataLabel() HandlerBlock()) |
    (<FINALLY> HandlerBlock())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void HandlerBlock():
{/*@bgen(jjtree) HandlerBlock */
  ASTHandlerBlock jjtn000 = new ASTHandlerBlock(JJTHANDLERBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HandlerBlock */
    try {
/*@egen*/
    (<HANDLER> DataLabel() <TO> DataLabel()) |
    (ScopeBlock())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FieldInit():
{/*@bgen(jjtree) FieldInit */
  ASTFieldInit jjtn000 = new ASTFieldInit(JJTFIELDINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldInit */
    try {
/*@egen*/
    (<BOOL_TYPE> <LEFT_PAREN> (<TRUE>|<FALSE>) <RIGHT_PAREN>)|
    (<BYTEARRAY> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<CHAR_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(3)
    (<FLOAT32> <LEFT_PAREN> Float32() <RIGHT_PAREN>) |
    LOOKAHEAD(3)
    (<FLOAT64> <LEFT_PAREN> Float64() <RIGHT_PAREN>) |
    LOOKAHEAD(3)
    (<FLOAT32> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    (<FLOAT64> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    ([<UNSIGNED>] <INT8_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    ([<UNSIGNED>] <INT16_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    ([<UNSIGNED>] <INT32_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    ([<UNSIGNED>] <INT64_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    (<UINT8_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    (<UINT16_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    (<UINT32_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    (<UINT64_TYPE> <LEFT_PAREN> Int32() <RIGHT_PAREN>) |
    (<QSTRING>) |
    (<NULLREF>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    
}

void MethodBodyItem():
{/*@bgen(jjtree) MethodBodyItem */
  ASTMethodBodyItem jjtn000 = new ASTMethodBodyItem(JJTMETHODBODYITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodBodyItem */
    try {
/*@egen*/
    (<CUSTOM> CustomDecl()) |
    (<DATA> DataDecl()) |
    (<EMITBYTE> Int32()) |
    (<ENTRYPOINT>) |
    (<LOCALS> [<INIT>] <LEFT_PAREN> LocalsSignature() <RIGHT_PAREN>) |
    (<MAXSTACK> Int32()) |
    LOOKAHEAD(2)
    (<OVERRIDE> <METHOD_TYPE> CallConv() Type() TypeSpec() <DOUBLE_COLON> MethodName() GenArity() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<OVERRIDE> TypeSpec() <DOUBLE_COLON> MethodName()) |
    LOOKAHEAD(2)
    (<PARAM> <LEFT_BRACKET> Int32() <RIGHT_BRACKET> [<EQUALS> FieldInit()]) |
    (<PARAM> <TYPE> <LEFT_BRACKET> Int32() <RIGHT_BRACKET>) |
    (ExternSourceDecl()) |
    (Instr()) |
    (Id() <COLON>) |
    (ScopeBlock()) |
    (SecurityDecl()) |
    (SEHBlock())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void MethodHeader() :
{/*@bgen(jjtree) MethodHeader */
  ASTMethodHeader jjtn000 = new ASTMethodHeader(JJTMETHODHEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodHeader */
    try {
/*@egen*/
    (MethAttr())* CallConv() Type() [ <MARSHAL> <LEFT_PAREN> [NativeType()] <RIGHT_PAREN> ] MethodName()
    [<LESS_THAN> GenPars() <GREATER_THAN>] <LEFT_PAREN> Parameters() <RIGHT_PAREN> (ImplAttr())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PinvAttr():
{/*@bgen(jjtree) PinvAttr */
  ASTPinvAttr jjtn000 = new ASTPinvAttr(JJTPINVATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PinvAttr */
    try {
/*@egen*/
    <ANSI>|
    <AUTOCHAR>|
    <CDECL>|
    <FASTCALL>|
    <STDCALL>|
    <THISCALL>|
    <UNICODE>|
    <PLATFORMAPI>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethAttr():
{/*@bgen(jjtree) MethAttr */
  ASTMethAttr jjtn000 = new ASTMethAttr(JJTMETHATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethAttr */
    try {
/*@egen*/
    (<ABSTRACT>) |
    (<ASSEMBLY_TYPE>) |
    (<COMPILERCONTROLLED>) |
    (<FAMANDASSEM>) |
    (<FAMILY>) |
    (<FAMORASSEM>) |
    (<FINAL>) |
    (<HIDEBYSIG>) |
    (<NEWSLOT>) |
    (<PINVOKEIMPL> <LEFT_PAREN> <QSTRING> [ <AS> <QSTRING>] (PinvAttr())* <RIGHT_PAREN>) |
    (<PRIVATE>) |
    (<PUBLIC>) |
    (<RTSPECIALNAME>) |
    (<SPECIALNAME>) |
    (<STATIC>) |
    (<VIRTUAL>) |
    (<STRICT>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void ImplAttr():
{/*@bgen(jjtree) ImplAttr */
  ASTImplAttr jjtn000 = new ASTImplAttr(JJTIMPLATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImplAttr */
    try {
/*@egen*/
    (<CIL>) |
    (<FORWARDREF>) |
    (<INTERNALCALL>) |
    (<MANAGED>) |
    (<NATIVE>) |
    (<NOINLINING>) |
    (<RUNTIME>) |
    (<SYNCHRONIZED>) |
    (<UNMANAGED>)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FieldDecl():
{/*@bgen(jjtree) FieldDecl */
  ASTFieldDecl jjtn000 = new ASTFieldDecl(JJTFIELDDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldDecl */
    try {
/*@egen*/
    [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET> ] (FieldAttr())* Type() Id() [(<EQUALS> FieldInit()) | (<AT> DataLabel())]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FieldAttr():
{/*@bgen(jjtree) FieldAttr */
  ASTFieldAttr jjtn000 = new ASTFieldAttr(JJTFIELDATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldAttr */
    try {
/*@egen*/
    (<ASSEMBLY_TYPE>)|
    (<FAMANDASSEM>) |
    (<FAMILY>) |
    (<FAMORASSEM>) |
    (<INITONLY>) |
    (<LITERAL>) |
    (<MARSHAL> <LEFT_PAREN> NativeType() <RIGHT_PAREN>) |
    (<NOTSERIALIZED>) |
    (<PRIVATE>) |
    (<COMPILERCONTROLLED>) |
    (<PUBLIC>) |
    (<RTSPECIALNAME>) |
    (<SPECIALNAME>) |
    (<STATIC>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DataDecl():
{/*@bgen(jjtree) DataDecl */
  ASTDataDecl jjtn000 = new ASTDataDecl(JJTDATADECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DataDecl */
    try {
/*@egen*/
    [<CIL>] [DataLabel() <EQUALS>] DdBody()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DdBody():
{/*@bgen(jjtree) DdBody */
  ASTDdBody jjtn000 = new ASTDdBody(JJTDDBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DdBody */
    try {
/*@egen*/
    (DdItem())|
    (<LEFT_BRACE> DdItemList() <RIGHT_BRACE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DdItemList():
{/*@bgen(jjtree) DdItemList */
  ASTDdItemList jjtn000 = new ASTDdItemList(JJTDDITEMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DdItemList */
    try {
/*@egen*/
    DdItem() [<COMMA> DdItemList()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DdItem():
{/*@bgen(jjtree) DdItem */
  ASTDdItem jjtn000 = new ASTDdItem(JJTDDITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DdItem */
    try {
/*@egen*/
    (<AMP> <LEFT_PAREN> Id() <RIGHT_PAREN>) |
    (<BYTEARRAY> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<CHAR_TYPE> <ASTERISK> <LEFT_PAREN> <QSTRING> <RIGHT_PAREN>) |
    (<FLOAT32> [ <LEFT_PAREN> Float64() <RIGHT_PAREN> ] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])|
    (<FLOAT64> [ <LEFT_PAREN> Float64() <RIGHT_PAREN> ] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])|
    (<INT8_TYPE> [ <LEFT_PAREN> Int32() <RIGHT_PAREN>] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])|
    (<INT16_TYPE> [ <LEFT_PAREN> Int32() <RIGHT_PAREN>] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])|
    (<INT32_TYPE> [ <LEFT_PAREN> Int32() <RIGHT_PAREN>] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])|
    (<INT64_TYPE> [ <LEFT_PAREN> Int32() <RIGHT_PAREN>] [ <LEFT_BRACKET> Int32() <RIGHT_BRACKET>])/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CustomDecl():
{/*@bgen(jjtree) CustomDecl */
  ASTCustomDecl jjtn000 = new ASTCustomDecl(JJTCUSTOMDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CustomDecl */
    try {
/*@egen*/
    Ctor() [<EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN>]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Ctor():
{/*@bgen(jjtree) Ctor */
  ASTCtor jjtn000 = new ASTCtor(JJTCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ctor */
     try {
/*@egen*/
     [<LEFT_PAREN> TypeReference() <RIGHT_PAREN>] CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] (<CTOR>|<CCTOR>) <LEFT_PAREN> Parameters() <RIGHT_PAREN>/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

void ExportAttr():
{/*@bgen(jjtree) ExportAttr */
  ASTExportAttr jjtn000 = new ASTExportAttr(JJTEXPORTATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExportAttr */
    try {
/*@egen*/
    (ClassAttr())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExternClassDecl():
{/*@bgen(jjtree) ExternClassDecl */
  ASTExternClassDecl jjtn000 = new ASTExternClassDecl(JJTEXTERNCLASSDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExternClassDecl */
    try {
/*@egen*/
    (<FILE> DottedName()) |
    LOOKAHEAD(2)
    (<CLASS> <EXTERN> DottedName()) |
    (<CLASS> Int32()) |
    (<CUSTOM> CustomDecl())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassHeader():
{/*@bgen(jjtree) ClassHeader */
    ASTClassHeader jjtn000 = new ASTClassHeader(JJTCLASSHEADER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token name;
}
{/*@bgen(jjtree) ClassHeader */
    try {
/*@egen*/
    (ClassAttr())*/*@bgen(jjtree) ClassName */
                   {
                     ASTClassName jjtn001 = new ASTClassName(JJTCLASSNAME);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/ DottedName()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                     }
                   }
/*@egen*/ [ (<LESS_THAN> GenPars() <GREATER_THAN>) ]
        [ (<EXTENDS> TypeSpec()) ] [ (<IMPLEMENTS> TypeSpec() ) ( <COMMA> TypeSpec() )* ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void GenPars():
{/*@bgen(jjtree) GenPars */
  ASTGenPars jjtn000 = new ASTGenPars(JJTGENPARS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenPars */
    try {
/*@egen*/
    GenPar() (<COMMA> GenPar())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GenPar():
{/*@bgen(jjtree) GenPar */
  ASTGenPar jjtn000 = new ASTGenPar(JJTGENPAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenPar */
    try {
/*@egen*/
    (  (GenParAttribs())* [ ( <LEFT_PAREN> [GenConstraints()] <RIGHT_PAREN> )] ) Id()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GenParAttribs():
{/*@bgen(jjtree) GenParAttribs */
  ASTGenParAttribs jjtn000 = new ASTGenParAttribs(JJTGENPARATTRIBS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenParAttribs */
    try {
/*@egen*/
    (<PLUS>)|
    (<MINUS>)|
    (<CLASS_TYPE>)|
    (<VALUETYPE>) |
    (<CTOR>)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GenConstraints():
{/*@bgen(jjtree) GenConstraints */
  ASTGenConstraints jjtn000 = new ASTGenConstraints(JJTGENCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenConstraints */
    try {
/*@egen*/
    TypeSpec() [ (<COMMA> GenConstraints()) ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassAttr():
{/*@bgen(jjtree) ClassAttr */
  ASTClassAttr jjtn000 = new ASTClassAttr(JJTCLASSATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassAttr */
    try {
/*@egen*/
    (<ABSTRACT>) |
    (<ANSI>) |
    (<AUTO>) |
    (<AUTOCHAR>) |
    (<BEFOREFIELDINIT>) |
    (<EXPLICIT>) |
    (<INTERFACE>) |
    LOOKAHEAD(2)
    (<NESTED> <ASSEMBLY_TYPE>) |
    LOOKAHEAD(2)
    (<NESTED> <FAMANDASSEM>) |
    LOOKAHEAD(2)
    (<NESTED> <FAMILY>) |
    LOOKAHEAD(2)
    (<NESTED> <FAMORASSEM>) |
    LOOKAHEAD(2)
    (<NESTED> <PRIVATE>) |
    LOOKAHEAD(2)
    (<NESTED> <PUBLIC>) |
    (<PRIVATE>) |
    (<PUBLIC>) |
    (<RTSPECIALNAME>) |
    (<SEALED>) |
    (<SEQUENTIAL>) |
    (<SERIALIZABLE>) |
    (<SPECIALNAME>) |
    (<UNICODE>) |
    (<IMPORT>)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassMember():
{/*@bgen(jjtree) ClassMember */
  ASTClassMember jjtn000 = new ASTClassMember(JJTCLASSMEMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassMember */
    try {
/*@egen*//*@bgen(jjtree) Class */
    {
      ASTClass jjtn001 = new ASTClass(JJTCLASS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<CLASS> ClassHeader() <LEFT_BRACE> (ClassMember())* <RIGHT_BRACE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |
    (<CUSTOM> CustomDecl()) |
    (<DATA> DataDecl()) |
    (<EVENT> EventHeader() <LEFT_BRACE> (EventMember())* <RIGHT_BRACE>) |
    (<FIELD> FieldDecl()) |
    (<METHOD> MethodHeader() <LEFT_BRACE> (MethodBodyItem())* <RIGHT_BRACE>) |
    LOOKAHEAD(2)
    (<OVERRIDE> TypeSpec() <DOUBLE_COLON> MethodName() <WITH> CallConv() Type() TypeSpec() <DOUBLE_COLON> MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<OVERRIDE> <METHOD_TYPE> CallConv() Type() TypeSpec() <DOUBLE_COLON> MethodName() GenArity() <LEFT_PAREN> Parameters() <RIGHT_PAREN> <WITH> <METHOD_TYPE> CallConv() Type() TypeSpec() <DOUBLE_COLON> MethodName() GenArity() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<PACK> Int32()) |
    (<PARAM> <TYPE> <LEFT_BRACKET> Int32() <RIGHT_BRACKET>) |
    (<PROPERTY> PropHeader() <LEFT_BRACE> (PropMember())* <RIGHT_BRACE>) |
    (<SIZE> Int32()) |
    (ExternSourceDecl()) |
    (SecurityDecl())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

void GenArity():
{/*@bgen(jjtree) GenArity */
  ASTGenArity jjtn000 = new ASTGenArity(JJTGENARITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenArity */
    try {
/*@egen*/
    [ <LESS_THAN> <LEFT_BRACKET> Int32() <RIGHT_BRACKET> <GREATER_THAN> ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//Id() -> DottedName() for interfaces from System
void PropHeader():
{/*@bgen(jjtree) PropHeader */
  ASTPropHeader jjtn000 = new ASTPropHeader(JJTPROPHEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropHeader */
    try {
/*@egen*/
    [<SPECIALNAME>][<RTSPECIALNAME>] CallConv() Type() DottedName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PropMember():
{/*@bgen(jjtree) PropMember */
  ASTPropMember jjtn000 = new ASTPropMember(JJTPROPMEMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropMember */
    try {
/*@egen*/
    (<CUSTOM> CustomDecl()) |
    (<GET> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<OTHER> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<SET> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (ExternSourceDecl())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodName() :
{/*@bgen(jjtree) MethodName */
    ASTMethodName jjtn000 = new ASTMethodName(JJTMETHODNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t = null;
}
{/*@bgen(jjtree) MethodName */
    try {
/*@egen*/
    ((t=<CCTOR>) |
    (t=<CTOR>) |
    (DottedName()))/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        if(t != null) jjtn000.setName(t.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EventHeader():
{/*@bgen(jjtree) EventHeader */
  ASTEventHeader jjtn000 = new ASTEventHeader(JJTEVENTHEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EventHeader */
    try {
/*@egen*/
    [<SPECIALNAME>] [<RTSPECIALNAME>] [LOOKAHEAD(2) TypeSpec()] Id()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EventMember():
{/*@bgen(jjtree) EventMember */
  ASTEventMember jjtn000 = new ASTEventMember(JJTEVENTMEMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EventMember */
    try {
/*@egen*/
    (<ADDON> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<FIRE> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<OTHER> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<REMOVEON> CallConv() Type() [LOOKAHEAD(2) TypeSpec() <DOUBLE_COLON>] MethodName() <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (<CUSTOM> CustomDecl()) |
    (ExternSourceDecl())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AsmRefDecl(): 
{/*@bgen(jjtree) AsmRefDecl */
  ASTAsmRefDecl jjtn000 = new ASTAsmRefDecl(JJTASMREFDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AsmRefDecl */
    try {
/*@egen*/
    (<ASSEMBLY> <EXTERN> DottedName() [ (<AS> DottedName()) ] <LEFT_BRACE> (AsmRefDecl())* <RIGHT_BRACE>) |
    (<CUSTOM> CustomDecl()) |
    (<HASH> <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<CULTURE> <QSTRING>) |
    (<PUBLICKEYTOKEN> <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN> ) |
    (<PUBLICKEY> <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<VER> Int32() <COLON> Int32() <COLON> Int32() <COLON> Int32())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AsmDecl() :
{/*@bgen(jjtree) AsmDecl */
  ASTAsmDecl jjtn000 = new ASTAsmDecl(JJTASMDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AsmDecl */
    try {
/*@egen*/
    (<CUSTOM> CustomDecl()) |
    (<HASH> <ALGORITHM> Int32()) |
    (<CULTURE> <QSTRING>) |
    (<PUBLICKEY> <EQUALS> <LEFT_PAREN> Bytes() <RIGHT_PAREN>) |
    (<VER> Int32() <COLON> Int32() <COLON> Int32() <COLON> Int32()) |
    (SecurityDecl())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Type():
{/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    (<METHOD_TYPE> CallConv() TypeBase() <ASTERISK> <LEFT_PAREN> Parameters() <RIGHT_PAREN>) |
    (TypeBase()  (LOOKAHEAD(4) TypeBase2())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//might need to make the bottom half one or more
void TypeBase():
{/*@bgen(jjtree) TypeBase */
  ASTTypeBase jjtn000 = new ASTTypeBase(JJTTYPEBASE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeBase */
    try {
/*@egen*/
    LOOKAHEAD(2)
    (<NOT> Int32()) |
    (<NOT> Id()) |
    LOOKAHEAD(2)
    (<DOUBLENOT> Int32()) |
    (<DOUBLENOT> Id()) |
    (<BOOL_TYPE>) |
    (<CHAR_TYPE>) |/*@bgen(jjtree) InspectableType */
    {
      ASTInspectableType jjtn001 = new ASTInspectableType(JJTINSPECTABLETYPE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<CLASS_TYPE> TypeReference())/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |
    (<FLOAT32>) |
    (<FLOAT64>) |
    (<INT8_TYPE>) |
    (<INT16_TYPE>) |
    (<INT32_TYPE>) |
    (<INT64_TYPE>) |
    (<UINT8_TYPE>) |
    (<UINT16_TYPE>) |
    (<UINT32_TYPE>) |
    (<UINT64_TYPE>) |
    LOOKAHEAD(2)
    (<NATIVE> <INT_TYPE>) |
    (<NATIVE> <UNSIGNED> <INT_TYPE>) |
    (<OBJECT_TYPE>) |
    (<STRING_TYPE>) |
    (<TYPEDREF>) |/*@bgen(jjtree) InspectableType */
    {
      ASTInspectableType jjtn002 = new ASTInspectableType(JJTINSPECTABLETYPE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    (<VALUETYPE> TypeReference())/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/ |
    LOOKAHEAD(2)
    (<UNSIGNED> <INT8_TYPE>) |
    LOOKAHEAD(2)
    (<UNSIGNED> <INT16_TYPE>) |
    LOOKAHEAD(2)
    (<UNSIGNED> <INT32_TYPE>) |
    LOOKAHEAD(2)
    (<UNSIGNED> <INT64_TYPE>) |
    (<VOID_TYPE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    
}

void TypeBase2():
{/*@bgen(jjtree) TypeBase2 */
  ASTTypeBase2 jjtn000 = new ASTTypeBase2(JJTTYPEBASE2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeBase2 */
    try {
/*@egen*/
    (<AMP>) |
        (<ASTERISK>) |
        (<LESS_THAN> GenArgs() <GREATER_THAN>) |
        (<LEFT_BRACKET> [  ( Bound() (<COMMA> Bound())*  ) ] <RIGHT_BRACKET>) |/*@bgen(jjtree) InspectableType */
        {
          ASTInspectableType jjtn001 = new ASTInspectableType(JJTINSPECTABLETYPE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        (<MODOPT> <LEFT_PAREN> TypeReference() <RIGHT_PAREN>)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/ |/*@bgen(jjtree) InspectableType */
        {
          ASTInspectableType jjtn002 = new ASTInspectableType(JJTINSPECTABLETYPE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
        (<MODREQ> <LEFT_PAREN> TypeReference() <RIGHT_PAREN>)/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/ |
        (<PINNED>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TypeSpec(): 
{/*@bgen(jjtree) TypeSpec */
  ASTTypeSpec jjtn000 = new ASTTypeSpec(JJTTYPESPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeSpec */
    try {
/*@egen*/
    LOOKAHEAD(3)/*@bgen(jjtree) InspectableType */
    {
      ASTInspectableType jjtn001 = new ASTInspectableType(JJTINSPECTABLETYPE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (TypeReference())/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |
    //(<LEFT_BRACKET> [ <MODULE> ] DottedName() <RIGHT_BRACKET>) |
    (Type())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Bound() :
{/*@bgen(jjtree) Bound */
  ASTBound jjtn000 = new ASTBound(JJTBOUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bound */
    try {
/*@egen*/

    LOOKAHEAD(3)
    (Int32() <ELIPSES> Int32()) |
    LOOKAHEAD(3)
    (Int32() <ELIPSES>) |
    (<ELIPSES>) |
    (Int32())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void GenArgs() :
{/*@bgen(jjtree) GenArgs */
  ASTGenArgs jjtn000 = new ASTGenArgs(JJTGENARGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GenArgs */
    try {
/*@egen*/
    Type() (LOOKAHEAD(2) <COMMA> Type())* (<COMMA>)*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Parameters():
{/*@bgen(jjtree) Parameters */
  ASTParameters jjtn000 = new ASTParameters(JJTPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameters */
    try {
/*@egen*/
    [Param() (<COMMA> Param())*]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Param():
{/*@bgen(jjtree) Param */
  ASTParam jjtn000 = new ASTParam(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Param */
    try {
/*@egen*/
    (<ELIPSES>) |
    ((ParamAttr())* Type() [<MARSHAL> <LEFT_PAREN> [NativeType()] <RIGHT_PAREN>] [Id()])/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ParamAttr():
{/*@bgen(jjtree) ParamAttr */
  ASTParamAttr jjtn000 = new ASTParamAttr(JJTPARAMATTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParamAttr */
    try {
/*@egen*/
    LOOKAHEAD(2)
    (<LEFT_BRACKET> <IN> <RIGHT_BRACKET>) |
    LOOKAHEAD(2)
    (<LEFT_BRACKET> <OUT> <RIGHT_BRACKET>) |
    (<LEFT_BRACKET> <OPT> <RIGHT_BRACKET>)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CallConv():
{/*@bgen(jjtree) CallConv */
  ASTCallConv jjtn000 = new ASTCallConv(JJTCALLCONV);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CallConv */
    try {
/*@egen*/
    [<INSTANCE>[<EXPLICIT>]] [CallKind()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CallKind():
{/*@bgen(jjtree) CallKind */
  ASTCallKind jjtn000 = new ASTCallKind(JJTCALLKIND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CallKind */
    try {
/*@egen*/
    (<DEFAULT_TOKEN>)|
    LOOKAHEAD(2)
    (<UNMANAGED> <CDECL>) |
    LOOKAHEAD(2)
    (<UNMANAGED> <FASTCALL>) |
    LOOKAHEAD(2)
    (<UNMANAGED> <STDCALL>) |
    LOOKAHEAD(2)
    (<UNMANAGED> <THISCALL>) |
    (<VARARG>)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TypeReference():
{/*@bgen(jjtree) TypeReference */
  ASTTypeReference jjtn000 = new ASTTypeReference(JJTTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeReference */
    try {
/*@egen*/
    [ResolutionScope()] DottedName() (<SLASH> DottedName())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ResolutionScope():
{/*@bgen(jjtree) ResolutionScope */
  ASTResolutionScope jjtn000 = new ASTResolutionScope(JJTRESOLUTIONSCOPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ResolutionScope */
    try {
/*@egen*/
    LOOKAHEAD(2)
    (<LEFT_BRACKET> <MODULE> Filename() <RIGHT_BRACKET>) |
    (<LEFT_BRACKET> AssemblyRefName() <RIGHT_BRACKET>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AssemblyRefName():
{/*@bgen(jjtree) AssemblyRefName */
  ASTAssemblyRefName jjtn000 = new ASTAssemblyRefName(JJTASSEMBLYREFNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssemblyRefName */
    try {
/*@egen*/
    DottedName()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//more potential one or manys
void NativeType():
{/*@bgen(jjtree) NativeType */
  ASTNativeType jjtn000 = new ASTNativeType(JJTNATIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NativeType */
    try {
/*@egen*/
    (<LEFT_BRACKET> <RIGHT_BRACKET>) |
    (<BOOL_TYPE>) |
    (<FLOAT32>) |
    (<FLOAT64>) |
    LOOKAHEAD(2)
    ( [<UNSIGNED>] <INT_TYPE>) |
    LOOKAHEAD(2)
    ( [<UNSIGNED>] <INT8_TYPE>) |
    LOOKAHEAD(2)
    ( [<UNSIGNED>] <INT16_TYPE>) |
    LOOKAHEAD(2)
    ( [<UNSIGNED>] <INT32_TYPE>) |
    LOOKAHEAD(2)
    ( [<UNSIGNED>] <INT64_TYPE>) |
    (<LPSTR>) |
    (<LPWSTR>) |
    (<METHOD_TYPE>) |
    (<AS> <ANY>) |
    (<BYVALSTR>) |
    (<CUSTOM_TYPE> <LEFT_PAREN> <QSTRING> <COMMA> <QSTRING> <RIGHT_PAREN>) |
    LOOKAHEAD(2)
    (<FIXED> <ARRAY> [Int32()]) |
    (<FIXED> <SYSSTRING> [Int32()]) |
    (<LPSTRUCT>) |
    (<LPTSTR>) |
    (<STRUCT>)
    [
        LOOKAHEAD(3)
        (<LEFT_BRACKET> <RIGHT_BRACKET>) |
        LOOKAHEAD(3)
        (<LEFT_BRACKET> Int32() <RIGHT_BRACKET>) |
        LOOKAHEAD(3)
        (<LEFT_BRACKET> <PLUS> Int32() <RIGHT_BRACKET>) |
        LOOKAHEAD(3)
        (<LEFT_BRACKET> Int32() <PLUS> Int32() <RIGHT_BRACKET>)
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ValueTypeReference():
{/*@bgen(jjtree) ValueTypeReference */
  ASTValueTypeReference jjtn000 = new ASTValueTypeReference(JJTVALUETYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ValueTypeReference */
    try {
/*@egen*//*@bgen(jjtree) InspectableType */
    {
      ASTInspectableType jjtn001 = new ASTInspectableType(JJTINSPECTABLETYPE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<BOXED> TypeReference())/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ |
    (<VALUETYPE> TypeReference())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Field(): 
{/*@bgen(jjtree) Field */
  ASTField jjtn000 = new ASTField(JJTFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Field */
    try {
/*@egen*/
    <FIELD> FieldDecl()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Int32():
{/*@bgen(jjtree) Int32 */
  ASTInt32 jjtn000 = new ASTInt32(JJTINT32);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Int32 */
    try {
/*@egen*/
    <DECIMAL_BYTE> | <DECIMAL_LITERAL> | <HEX_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void HexByte():
{/*@bgen(jjtree) HexByte */
  ASTHexByte jjtn000 = new ASTHexByte(JJTHEXBYTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HexByte */
    try {
/*@egen*/
    <DECIMAL_BYTE> | <HEX_BYTE> | <HEX_VALID_ID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RealNumber():
{/*@bgen(jjtree) RealNumber */
  ASTRealNumber jjtn000 = new ASTRealNumber(JJTREALNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RealNumber */
    try {
/*@egen*/
    LOOKAHEAD(2)
    ((<DECIMAL_LITERAL>|<DECIMAL_BYTE>) <DOT> [(<DECIMAL_LITERAL>|<DECIMAL_BYTE>)] [<EXPONENT>]) |
    (<DOT> (<DECIMAL_LITERAL>|<DECIMAL_BYTE>) [<EXPONENT>]) |
    ((<DECIMAL_LITERAL>|<DECIMAL_BYTE>) <EXPONENT>) |
    (<REAL_PIECE> [<EXPONENT>])/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* LITERALS */

TOKEN :
{
  < HEX_VALID_ID: (["a"-"f","A"-"F"]) (["0"-"9","a"-"f","A"-"F"]) >
|
  < DECIMAL_BYTE: (["0"-"9"]) (["0"-"9"])>
|
  < HEX_BYTE: (["0"-"9","a"-"f","A"-"F"]) (["0"-"9","a"-"f","A"-"F"]) >
|
  < DECIMAL_LITERAL: ("-")? ["0"-"9"] (["0"-"9"])* >
|
  < HEX_LITERAL: "0x" (["0"-"9","a"-"f","A"-"F"])+ >
/*|
  < REAL_NUMBER:
        ((["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?) 
      | ("." (["0"-"9"])+ (<EXPONENT>)? )
      | ((["0"-"9"])+ <EXPONENT> )
  >*/
|
  < REAL_PIECE: (["0"-"9"])+ "." (["0"-"9"])+ >
|
  < EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >

|
  < QSTRING:
    <QSTRING_LITERAL_PIECE> ((["\r","\n"," ","\t"])* "+" (["\r","\n"," ","\t"])* (<QSTRING_LITERAL_PIECE>))*
  >
|
  < SQSTRING:
    <SQSTRING_LITERAL_PIECE> ((["\r","\n"," ","\t"])* "+" (["\r","\n"," ","\t"])* (<SQSTRING_LITERAL_PIECE>))*
  >
|
  <#QSTRING_LITERAL_PIECE:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( (~["0"-"7"])
            | (["0"-"7"] ( ["0"-"7"] )?)
            | (["0"-"3"] ["0"-"7"] ["0"-"7"])
            )
          )
      )*
      "\""
  >
|
  <#SQSTRING_LITERAL_PIECE:
      "\'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( (["n","t","\\","\'","\""])
            | (["0"-"7"] ( ["0"-"7"] )?)
            | (["0"-"3"] ["0"-"7"] ["0"-"7"])
            )
          )
      )*
      "\'"
  >
|
  < DOTTED_NAME:
    (<ID> | <SQSTRING> | <HEX_VALID_ID>) ("." (<ID> | <SQSTRING> | <HEX_VALID_ID>))+
  >
|
  < ID:
     (["A"-"Z","a"-"z","_","$","@","`","?"])
     (["0"-"9","A"-"Z","a"-"z","_","$","@","`","?"])*
  >
}