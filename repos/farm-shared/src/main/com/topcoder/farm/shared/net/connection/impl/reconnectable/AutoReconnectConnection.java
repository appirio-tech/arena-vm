/*
 * AutoReconnectConnection
 *
 * Created 06/29/2006
 */
package com.topcoder.farm.shared.net.connection.impl.reconnectable;

import java.io.IOException;

import com.topcoder.farm.shared.net.connection.api.Connection;
import com.topcoder.farm.shared.net.connection.api.ConnectionFactory;
import com.topcoder.farm.shared.net.connection.api.ConnectionHandler;
import com.topcoder.farm.shared.net.connection.api.ReconnectableConnection;
import com.topcoder.farm.shared.net.connection.api.ReconnectableConnectionHandler;
import com.topcoder.farm.shared.net.connection.impl.AbstractDecoratedConnection;
import com.topcoder.farm.shared.net.connection.impl.ConnectionState;
import com.topcoder.shared.util.concurrent.Waiter;

/**
 * This class provides a basic reconnection behaviour.
 * It uses a ConnectionFactory to obtain the initial decorated connection.
 * The status of the decorated connection is monitored and when is reported as lost,
 * a reconnection attempt starts. This reconnect attempt tries to create a
 * new connection using the factory. If after maxTries tries the factory
 * couldn't create a connection, this connection is reported as Lost.
 *
 *
 * @author Diego Belfer (mural)
 * @version $Id$
 */
public class AutoReconnectConnection extends AbstractDecoratedConnection implements ReconnectableConnection {
    /**
     * Max default to wait when a send is invoked and a reconnection attempt is being made
     */
    private static final long MAX_WAIT_SEND_RECONNECT = 5000; //FIXME remove hardcode

    /**
     * Factory used to obtain a new connection every time the actual connection is lost
     */
    private ConnectionFactory factory;

    /**
     * MaxTries to reconnect during an attempt
     */
    private int maxTries;

    /**
     * Only one thread must try to reconnect at any time
     */
    private Object reconnectMutex = new Object();

    /**
     * Field that contains the number of tries a reconnect attempt
     * was try and it did not finish correctly
     */
    private int previousTryCount;

    private Thread reconnectingThread;

    /**
     * Time in ms to wait before trying again
     * after an attempt to get a connection failed
     */
    private int msBetweenTries;

    /**
     * Creates a AutoReconectConnection that will use the provided <code>factory</code>
     * to obtain connections
     *
     * @param factory Factory to use to obtain connection
     * @param maxTries How many reconnection attempts must be done before giving the connection
     *                  as lost.
     * @param msBetweenTries Time in ms to wait before trying again
     *                       after an attempt to get a connection failed
     * @throws IOException If the connection could not be created
     */
    public AutoReconnectConnection(ConnectionFactory factory, int maxTries, int msBetweenTries) throws IOException {
        this.factory = factory;
        this.maxTries = maxTries;
        this.msBetweenTries = msBetweenTries;
        setConnection(factory.create());

    }

    /**
     * Creates a AutoReconectConnection that will use the provided <code>factory</code>
     * to obtain connections
     *
     * @param factory Factory to use to obtain connection
     * @param maxTries The maximum number of reconnection attempts
     * @param msBetweenTries Time in ms to wait before trying again
     *                       after an attempt to get a connection failed
     * @param handler Handler that will manage events generated by this connection
     *
     * @throws IOException If the connection could not be created
     */
    public AutoReconnectConnection(ConnectionFactory factory, int maxTries, int msBetweenTries, ReconnectableConnectionHandler handler) throws IOException {
        this.factory = factory;
        this.maxTries = maxTries;
        this.msBetweenTries = msBetweenTries;
        setHandler(handler);
        setConnection(factory.create());
    }

    /**
     * Try to get a new connection using the factory
     */
    protected void doReconnect() {
        synchronized (reconnectMutex) {
            if (reconnectingThread != null) {
                try {
                    reconnectingThread.join(0);
                } catch (InterruptedException e) {
                    throw new IllegalStateException("");
                }
            }
            if (!isClosed()) {
                reconnectingThread = new Thread() {
                            public void run() {
                                log.info("Starting reconnection attempt");
                                releaseConnection();
                                notifyReconnecting();
                                boolean succeed = false;
                                int tries = previousTryCount;
                                Connection newConnection = null;
                                while (!succeed && shouldReconnect(tries)) {
                                    try {
                                        releaseConnection();
                                        stateLock.lock();
                                        try {
                                            newConnection = factory.create();
                                            setConnection(newConnection);
                                            setState(ReconnectingWithConnectionState.getInstance());
                                        } finally {
                                            stateLock.unlock();
                                        }
                                        succeed = true;
                                        try {
                                            getReconnectableHandler().performReconnection(AutoReconnectConnection.this);
                                        } catch (Exception e) {
                                            log.warn("The performReconnection thrown an exception.",e);
                                            succeed = false;
                                        }
                                    } catch (Exception e) {
                                        succeed = false;
                                    } finally {
                                        tries++;
                                        try {
                                            if (!succeed && shouldReconnect(tries)) {
                                                Thread.sleep(msBetweenTries);
                                            }
                                        } catch (Exception ex) {
                                           break;
                                        }
                                    }
                                }
                                if (!succeed && !shouldReconnect(tries)) {
                                    log.info("Reconnect failed");
                                    releaseConnection();
                                    handleConnectionReconnectFail();
                                } else {
                                    log.info("Reconnect succeeded");
                                    stateLock.lock();
                                    try {
                                        try {
                                            handleReconnectSucceed();
                                        } catch (Exception e) {
                                            log.error("Exception thrown while notifying reconnection. Retrying reconnection process.", e);
                                            releaseConnection();
                                            setState(ReconnectingState.getInstance());
                                            succeed = false;
                                        }
                                        if (!getConnection().isLost()) {
                                            previousTryCount = 0;
                                        } else {
                                            previousTryCount = tries;
                                        }
                                    } finally {
                                        stateLock.unlock();
                                    }
                                }
                            }
                        };
                        //If nothing else is running, just exit VM
                        reconnectingThread.setDaemon(true);
                        reconnectingThread.start();
            }
        }
    }

    /**
     * Handles the failure of the reconnection attempt
     *
     * SubClasses must invoke this method when the reconnection attempt
     * was unsuccessful.
     *
     * Handles synchronization issues that could occur
     * during state delegation and transition.
     */
    public void handleConnectionReconnectFail() {
        int lckCnt = stateLock.lock();
        try {
            getReconnectableState().handleReconnectFail(this);
        } catch (Exception e) {
            log.warn("Exception raise during event notification",e);
        } finally {
            stateLock.tryToUnlock(lckCnt);
        }
    }


    /**
    * Handles reconnection attempt success
    *
    * SubClasses must invoke this method when the reconnection attempt
    * was successful.
    *
    * Handles synchronization issues that could occur
    * during state delegation and transition.
    */
    public void handleReconnectSucceed() {
        int lckCnt = stateLock.lock();
        try {
            getReconnectableState().handleReconnectSucceed(this);
        } catch (Exception e) {
            log.warn("Exception raise during event notification",e);
        } finally {
            stateLock.tryToUnlock(lckCnt);
        }
    }

    /**
     * Helper returning a casted version of the state
     * @return the state of the connection
     */
    private ReconnectableConnectionState getReconnectableState() {
        return (ReconnectableConnectionState) getState();
    }

    private boolean shouldReconnect(int tries) {
        return !isClosed() && tries < maxTries;
    }


    /**
     * State transition from Connected To Reconnecting
     * Impl: Changes the state and does the operation implied by the transition
     *
     * Default operation: doReconnect
     */
    public void stateChangingFromConnectedToReconnecting() {
        setState(getReconnectingState());
        stateLock.unlock();
        doReconnect();
    }

    /**
     * State transition from Reconnecting to Lost
     * Impl: Changes the state and does the operation implied by the transition
     *
     * Default operation: doHandleConnectionLost
     */
    public void stateChangingFromReconnectingToLost() {
        setState(getLostState());
        stateLock.unlock();
        doHandleConnectionLost();
    }

    /**
     * State transition from Reconnecting to Connected
     * Impl: Changes the state and does the operation implied by the transition
     *
     * Default operation: doHandleReconnected
     */
    public void stateChangingFromReconnectingToConnected() {
        setState(getConnectedState());
        stateLock.unlock();
        doHandleReconnected();
    }


    /**
     * State transition from Reconnecting to Closing
     * Impl: Changes the state and does the operation implied by the transition
     *
     * Default operation: doHandleReconnected
     */
    public void stateChangingFromReconnectingToClosing() {
        setState(getClosingState());
        stateLock.unlock();
    }

    /**
     * Actual handling of the reconnected event.
     *
     * Note: State was changed previously
     */
    protected void doHandleReconnected() {
        notifyReconnected();
    }

    /**
     * Notifies the handler the reconnection attempt succeeded
     */
    protected void notifyReconnected() {
        getReconnectableHandler().reconnected(this);
    }

    /**
     * Notifies the handler that a reconnection attempt has started
     */
    protected void notifyReconnecting() {
        getReconnectableHandler().reconnecting(this);
    }

    /**
     * Override parent method to check ReconnectableConnectionHandler is
     * being give as argument
     */
    public void setHandler(ConnectionHandler handler) {
        setHandler((ReconnectableConnectionHandler) handler);
    }

    /**
     * Sets the connection event handler for this connection
     */
    public void setHandler(ReconnectableConnectionHandler handler) {
        super.setHandler(handler);
    }

    /**
     * @return the ReconnectableConnectionHandler handler
     */
    public ReconnectableConnectionHandler getReconnectableHandler() {
        return (ReconnectableConnectionHandler) super.getHandler();
    }

    public void forceReconnect() {
        handleConnectionLost();
    }

    /**
     * This method is called by the ReconnectingState when the send
     * method is invoked in the connection.
     *
     * @param object object sent
     * @throws ReconnectingException
     */
    void sendOnReconnect(Object object) throws IOException {
        if (!isConnected() && !isClosed()) {
            if (Thread.currentThread() != reconnectingThread) {
                Waiter waiter = new Waiter(MAX_WAIT_SEND_RECONNECT, reconnectMutex);
                log.info("Stopping thread trying to send due to reconnection attemp.");
                while (!waiter.elapsed() && !isConnected() && !isClosed()) {
                   try {
                       synchronized (reconnectMutex) {
                           //FIXME wrong....Fixing bug. Review join in the reconnect method
                           if (log.isDebugEnabled()) {
                               log.debug("waiting :"+waiter.getRemaining());
                           }
                           waiter.await();
                       }
                   } catch (InterruptedException e) {
                       Thread.currentThread().interrupt();
                       break;
                   }
                }
                log.info("Releasing thread trying to send due to reconnection attemp.");
                if (!isConnected()) {
                    throw new ReconnectingException();
                }
            }
        }
        bareSend(object);
    }

    private boolean isConnected() {
        return getConnectedState().equals(getState());
    }

    /**
     * This method is called by the ReconnectingState when the connection
     * just created is lost before the reconnection attemp ends
     */
    void lostOnReconnect() {
    }


    //States
    /**
     * Returns the connected state for this Connection
     */
    protected ConnectionState getConnectedState() {
        return ReconnectableConnectedState.getInstance();
    }

    /**
     * Returns the closed state for this Connection
     */
    protected ConnectionState getClosedState() {
        return ReconnectableClosedState.getInstance();
    }

    /**
     * Returns the closing state for this Connection
     */
    protected ConnectionState getClosingState() {
        return ReconnectableClosingState.getInstance();
    }

    /**
     * Returns the Lost state for this Connection
     */
    protected ConnectionState getLostState() {
        return ReconnectableLostState.getInstance();
    }

    /**
     * Returns the reconnecting state for this Connection
     */
    protected ConnectionState getReconnectingState() {
        return ReconnectingState.getInstance();
    }

    /**
     * @see com.topcoder.farm.shared.net.connection.impl.AbstractConnection#getNullHandler()
     */
    protected ConnectionHandler getNullHandler() {
        return NullReconnectableConnectionHandler.INSTANCE;
    }


    protected void release() {
        super.release();
        Thread thread = reconnectingThread;
        if (thread != null) {
            thread.interrupt();
        }
        thread = null;
    }

    public String toString() {
        return "AutoReconnectConnection[connection="+getConnection()+", state="+getState()+"]";
    }
}
